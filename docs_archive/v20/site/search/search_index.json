{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Runtime Editor Docs Welcome to documentation of Runtime Editor the set of scripts and prefabs which help you to implement scene editor, game level editor or build your own modeling application. If you are new to this documentation you could proceed to introduction page to get an overview what Runtime Editor and this documentation has to offer. Note If you cannot find something in the documentation or have any questions, send an email to Battlehub@outlook.com or ask directly in this support group . The documentation is organized as following: General Introduction List of Features About Getting Started Getting Started with Transform Handles Getting Started with Runtime Editor Getting Started with Save & Load Expose To Editor Event methods IOC Runtime Selection Runtime Undo Transform Handles Overview Getting Started Base Handle Position Handle Rotation Handle Scale Handle Locking Axes Scene Gizmo Selection Gizmo Grid Box Selection Runtime Handles Component Runtime Selection Component Runtime Scene Component Common Infrastructure Overview Expose To Editor Event methods IOC Input IRTE interface RTE Component Runtime Tools Runtime Objects Runtime Selection Runtime Undo Drag And Drop Runtime Window Runtime Editor Overview Getting Started Runtime Editor Main & Context Menu RTEDeps Window Manager How To: How to add custom window to Window Manager Inspector View How To: Configure Editors How To: Select Component Properties Save Load Overview Getting Started Persistent Classes How To: Create Custom Persistent Class Asset Library How To: Create Asset Library Project Item & Asset Item Project Rendering IGL GLRenderer GLCamera Runtime Graphics Layer Gizmos Overview Getting Started With Gizmos Box Gizmo Sphere Gizmo Capsule Gizmo Cone Gizmo Box Collider Gizmo Capsule Collider Gizmo Point Light Gizmo Spot Light Gizmo Directional Light Gizmo Audio Source Gizmo Audio Reverb Zone Gimzo Skinned Mesh Renderer Gizmo Dock Panel Overview Getting Started Dock Panel Tab Tab Preview Region Dialog Manager Virtualizing TreeView Overview Getting Started Virtualizing Scroll Rect Virtualizing Items Control Virtualizing Drop Marker Virtualizing Tree View Virtualizing Tree View Item Menu Control Overview Getting Started Menu Item Menu Main Menu Button Context Menu Trigger","title":"Home"},{"location":"#runtime-editor-docs","text":"Welcome to documentation of Runtime Editor the set of scripts and prefabs which help you to implement scene editor, game level editor or build your own modeling application. If you are new to this documentation you could proceed to introduction page to get an overview what Runtime Editor and this documentation has to offer. Note If you cannot find something in the documentation or have any questions, send an email to Battlehub@outlook.com or ask directly in this support group . The documentation is organized as following:","title":"Runtime Editor Docs"},{"location":"#general","text":"Introduction List of Features About","title":"General"},{"location":"#getting-started","text":"Getting Started with Transform Handles Getting Started with Runtime Editor Getting Started with Save & Load Expose To Editor Event methods IOC Runtime Selection Runtime Undo","title":"Getting Started"},{"location":"#transform-handles","text":"Overview Getting Started Base Handle Position Handle Rotation Handle Scale Handle Locking Axes Scene Gizmo Selection Gizmo Grid Box Selection Runtime Handles Component Runtime Selection Component Runtime Scene Component","title":"Transform Handles"},{"location":"#common-infrastructure","text":"Overview Expose To Editor Event methods IOC Input IRTE interface RTE Component Runtime Tools Runtime Objects Runtime Selection Runtime Undo Drag And Drop Runtime Window","title":"Common Infrastructure"},{"location":"#runtime-editor","text":"Overview Getting Started Runtime Editor Main & Context Menu RTEDeps Window Manager How To: How to add custom window to Window Manager Inspector View How To: Configure Editors How To: Select Component Properties","title":"Runtime Editor"},{"location":"#save-load","text":"Overview Getting Started Persistent Classes How To: Create Custom Persistent Class Asset Library How To: Create Asset Library Project Item & Asset Item Project","title":"Save Load"},{"location":"#rendering","text":"IGL GLRenderer GLCamera Runtime Graphics Layer","title":"Rendering"},{"location":"#gizmos","text":"Overview Getting Started With Gizmos Box Gizmo Sphere Gizmo Capsule Gizmo Cone Gizmo Box Collider Gizmo Capsule Collider Gizmo Point Light Gizmo Spot Light Gizmo Directional Light Gizmo Audio Source Gizmo Audio Reverb Zone Gimzo Skinned Mesh Renderer Gizmo","title":"Gizmos"},{"location":"#dock-panel","text":"Overview Getting Started Dock Panel Tab Tab Preview Region Dialog Manager","title":"Dock Panel"},{"location":"#virtualizing-treeview","text":"Overview Getting Started Virtualizing Scroll Rect Virtualizing Items Control Virtualizing Drop Marker Virtualizing Tree View Virtualizing Tree View Item","title":"Virtualizing TreeView"},{"location":"#menu-control","text":"Overview Getting Started Menu Item Menu Main Menu Button Context Menu Trigger","title":"Menu Control"},{"location":"dock-panels/","text":"Dock Panel Docs Overview The Dock Panel is a control, that provides an easy docking of content regions to the left, right, top, bottom or center of the panel. The control also allow region to become an independent floating window, modal popup or dialog. Getting Started Create Canvas. Add DockPanel.prefab from Assets/Battelhub/UIControls/DockPanels/Prefabs to hierarchy. Create GettingStarted.cs script and add it to DockPanel Game Object. Hit Play. using Battlehub.UIControls.DockPanels; using UnityEngine; using UnityEngine.UI; public class GettingStarted : MonoBehaviour { DockPanel m_dockPanel; void Start() { m_dockPanel = GetComponent<DockPanel>(); GameObject testContent = new GameObject(); testContent.AddComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f, 1.0f); LayoutInfo layout = new LayoutInfo(false, new LayoutInfo(testContent.transform, \"Tab 1\"), new LayoutInfo( isVertical: true, child0: new LayoutInfo(Instantiate(testContent).transform, \"Tab 2\"), child1: new LayoutInfo(Instantiate(testContent).transform, \"Tab 3\"), ratio: 0.5f), 0.5f); m_dockPanel.RootRegion.Build(layout); } } Note Full demo can be found in Assets/Battelhub/UIControls/DockPanels/Demo folder Dock Panel Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ DockPanel.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ DockPanel.cs Fields: Mask - masking everything outside of DockPanel (image with Mask Component) Docked - parent for docked regions Free - parent for floating regions Preview - parent for tab preview visible during tab re-parenting operation. Modal - parent for modal pop-ups and dialogs. Region Prefab - reference to region prefab. Tab Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ Tab.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ Tab.cs Fields: Tab Preivew Prefab - reference to tab-preview.prefab . Canvas Group - required to hide tab but preserve occupied space during rearrangements. Img - tab icon. Text - tab header text. Close Button - tab close button. Toggle - reference to toggle control (tab have 2 states 'selected' and 'unselected'). Tab Preview Tab Preview become visible during tab rearrangements. Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ TabPreview.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ TabPreview.cs Fields: Img - tab preview icon (replaced with tab sprite during rearrangements). Text - tab preview text (replaced with tab text during rearrangements). Content Part - content preview (resized according to available space during rearrangements). Region Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ Region.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ Region.cs Fields: Maximize Toggle - expands owner region and hide others. Can Resize - enables/disable ability to resize region. Layout Element - reference to root Layout Element. Tab Panel - panel for tabs . Content Panel - panel for content. Children Panel - panel for child regions. Tab Prefab - reference to tab prefab. Root - reference to dock panel . Header Image - region header graphics. Frame Image - region content frame graphics. Methods: void Build(LayoutInfo layoutInfo) - build layout. GameObject content1 = new GameObject(); content1.AddComponent<Image>().color = Color.red; GameObject content2 = new GameObject(); content2.AddComponent<Image>().color = Color.yellow; m_region.Build(new LayoutInfo( isVertical: false, child0: new LayoutInfo(content1.transform, \"Header 1\"), child1: new LayoutInfo(content2.transform, \"Header 2\"), ratio: 0.25f)); void RemoveAt(int index) - remove content at index. void Add(Sprite icon, string header, Transform content, bool isFree = false, RegionSplitType splitType = RegionSplitType.None) - add content to region. Sprite icon = null; GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.green; //1. Add content m_region.Add(icon, \"Header1\", content.transform, false, RegionSplitType.None); //2. Add content to the left m_region.Add(icon, \"Header2\", content.transform, false, RegionSplitType.Left); //3. Add content to the right m_region.Add(icon, \"Header3\", content.transform, false, RegionSplitType.Right); //4. Add content on the top m_region.Add(icon, \"Header4\", content.transform, false, RegionSplitType.Top); //5. Add content to the bottom m_region.Add(icon, \"Header5\", content.transform, false, RegionSplitType.Bottom); //6. Add content to floating region m_region.Add(icon, \"Tab 3\", content.transform, true); Dialog Manager Dialog manager allows you to create various dialogs and pop-ups. Dialogs are created as a modal floating regions of dock panel . To use dialog manager do following: Add Assets/Battelhub/UIControls/Dialog/Scripts/ DialogManager component Set Dock Panel field Set Dialog field to Assets/Battelhub/UIControls/Dialog/Prefabs/ Dialog.prefab using Battlehub.UIControls.Dialogs; using UnityEngine; using UnityEngine.UI; public class DialogManagerExamples : MonoBehaviour { [SerializeField] DialogManager m_dialogManager; [SerializeField] Sprite m_icon; void Start() { //Show message box with \"OK\" button m_dialogManager.ShowDialog(m_icon, \"Message Header\", \"Message Text\"); //Show confirmation with \"Yes\" and \"No\" buttons m_dialogManager.ShowDialog(m_icon, \"Scene has been modified\", \"Do you want to save changed you made in the scene?\", (dialog, cancelArgs) => { Debug.Log(\"Yes clicked\"); }, \"Yes\", (dialog, cancelArgs) => { Debug.Log(\"No clicked\"); }, \"No\"); //Show popup with custom content GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.red; m_dialogManager.ShowDialog(m_icon, \"Popup\", content.transform); } }","title":"Dock Panels"},{"location":"dock-panels/#dock-panel-docs","text":"","title":"Dock Panel Docs"},{"location":"dock-panels/#overview","text":"The Dock Panel is a control, that provides an easy docking of content regions to the left, right, top, bottom or center of the panel. The control also allow region to become an independent floating window, modal popup or dialog.","title":"Overview"},{"location":"dock-panels/#getting-started","text":"Create Canvas. Add DockPanel.prefab from Assets/Battelhub/UIControls/DockPanels/Prefabs to hierarchy. Create GettingStarted.cs script and add it to DockPanel Game Object. Hit Play. using Battlehub.UIControls.DockPanels; using UnityEngine; using UnityEngine.UI; public class GettingStarted : MonoBehaviour { DockPanel m_dockPanel; void Start() { m_dockPanel = GetComponent<DockPanel>(); GameObject testContent = new GameObject(); testContent.AddComponent<Image>().color = new Color(0.2f, 0.2f, 0.2f, 1.0f); LayoutInfo layout = new LayoutInfo(false, new LayoutInfo(testContent.transform, \"Tab 1\"), new LayoutInfo( isVertical: true, child0: new LayoutInfo(Instantiate(testContent).transform, \"Tab 2\"), child1: new LayoutInfo(Instantiate(testContent).transform, \"Tab 3\"), ratio: 0.5f), 0.5f); m_dockPanel.RootRegion.Build(layout); } } Note Full demo can be found in Assets/Battelhub/UIControls/DockPanels/Demo folder","title":"Getting Started"},{"location":"dock-panels/#dock-panel","text":"Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ DockPanel.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ DockPanel.cs Fields: Mask - masking everything outside of DockPanel (image with Mask Component) Docked - parent for docked regions Free - parent for floating regions Preview - parent for tab preview visible during tab re-parenting operation. Modal - parent for modal pop-ups and dialogs. Region Prefab - reference to region prefab.","title":"Dock Panel"},{"location":"dock-panels/#tab","text":"Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ Tab.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ Tab.cs Fields: Tab Preivew Prefab - reference to tab-preview.prefab . Canvas Group - required to hide tab but preserve occupied space during rearrangements. Img - tab icon. Text - tab header text. Close Button - tab close button. Toggle - reference to toggle control (tab have 2 states 'selected' and 'unselected').","title":"Tab"},{"location":"dock-panels/#tab-preview","text":"Tab Preview become visible during tab rearrangements. Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ TabPreview.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ TabPreview.cs Fields: Img - tab preview icon (replaced with tab sprite during rearrangements). Text - tab preview text (replaced with tab text during rearrangements). Content Part - content preview (resized according to available space during rearrangements).","title":"Tab Preview"},{"location":"dock-panels/#region","text":"Default Style: Structure: Prefab: Assets/Battelhub/UIControls/DockPanels/Prefabs/ Region.prefab Script: Assets/Battelhub/UIControls/DockPanels/Scripts/ Region.cs Fields: Maximize Toggle - expands owner region and hide others. Can Resize - enables/disable ability to resize region. Layout Element - reference to root Layout Element. Tab Panel - panel for tabs . Content Panel - panel for content. Children Panel - panel for child regions. Tab Prefab - reference to tab prefab. Root - reference to dock panel . Header Image - region header graphics. Frame Image - region content frame graphics. Methods: void Build(LayoutInfo layoutInfo) - build layout. GameObject content1 = new GameObject(); content1.AddComponent<Image>().color = Color.red; GameObject content2 = new GameObject(); content2.AddComponent<Image>().color = Color.yellow; m_region.Build(new LayoutInfo( isVertical: false, child0: new LayoutInfo(content1.transform, \"Header 1\"), child1: new LayoutInfo(content2.transform, \"Header 2\"), ratio: 0.25f)); void RemoveAt(int index) - remove content at index. void Add(Sprite icon, string header, Transform content, bool isFree = false, RegionSplitType splitType = RegionSplitType.None) - add content to region. Sprite icon = null; GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.green; //1. Add content m_region.Add(icon, \"Header1\", content.transform, false, RegionSplitType.None); //2. Add content to the left m_region.Add(icon, \"Header2\", content.transform, false, RegionSplitType.Left); //3. Add content to the right m_region.Add(icon, \"Header3\", content.transform, false, RegionSplitType.Right); //4. Add content on the top m_region.Add(icon, \"Header4\", content.transform, false, RegionSplitType.Top); //5. Add content to the bottom m_region.Add(icon, \"Header5\", content.transform, false, RegionSplitType.Bottom); //6. Add content to floating region m_region.Add(icon, \"Tab 3\", content.transform, true);","title":"Region"},{"location":"dock-panels/#dialog-manager","text":"Dialog manager allows you to create various dialogs and pop-ups. Dialogs are created as a modal floating regions of dock panel . To use dialog manager do following: Add Assets/Battelhub/UIControls/Dialog/Scripts/ DialogManager component Set Dock Panel field Set Dialog field to Assets/Battelhub/UIControls/Dialog/Prefabs/ Dialog.prefab using Battlehub.UIControls.Dialogs; using UnityEngine; using UnityEngine.UI; public class DialogManagerExamples : MonoBehaviour { [SerializeField] DialogManager m_dialogManager; [SerializeField] Sprite m_icon; void Start() { //Show message box with \"OK\" button m_dialogManager.ShowDialog(m_icon, \"Message Header\", \"Message Text\"); //Show confirmation with \"Yes\" and \"No\" buttons m_dialogManager.ShowDialog(m_icon, \"Scene has been modified\", \"Do you want to save changed you made in the scene?\", (dialog, cancelArgs) => { Debug.Log(\"Yes clicked\"); }, \"Yes\", (dialog, cancelArgs) => { Debug.Log(\"No clicked\"); }, \"No\"); //Show popup with custom content GameObject content = new GameObject(); content.AddComponent<Image>().color = Color.red; m_dialogManager.ShowDialog(m_icon, \"Popup\", content.transform); } }","title":"Dialog Manager"},{"location":"general/","text":"Introduction This documentation covers most important parts of Runtime Editor. Unlike previous versions of the documentation, I tried to concentrate more on examples rather then documenting each property of each script. Let me know what examples you would like to see. Start with following sections: Getting Started with Transform Handles Getting Started with Runtime Editor Getting Started with Save & Load Expose To Editor Event methods IOC Runtime Selection Runtime Undo List of Features Position, Rotation, Scale Handles. Grid, Box Selection, Scene Gizmo. Transform Handles mobile & Google AR Core support. Global & Local coordinates, Local & Center pivot point modes, Vertex & Grid snapping. Gizmos for Colliders, Lights and Audio Sources. Scene navigation, Orthographic & Perspective view. Undo & Redo API. Object selection API. Object life-cycle Events. Play & Edit mode. Configurable Inspector . Component & Material editors. 16 Built-in property editors. Add Component control. Multiple Scenes and Cameras support. Dock Panels & Windows Management. Dialogs, Message Boxes, Confirmations. Easy to extend with new windows. Configurable Main & Context menu . Fast Virtualizing Tree View for Hierarchy and Project windows. Configurable Save & Load subsystem (almost no coding is required). Easy to use Project API . Static Assets, Asset Bundles and Dynamic Assets support . Load assets on demand. Multiple Projects support. Upgrade note Many breaking changes have been made since version 1.3.2u3. Runtime Save Load and some other parts were completely rewritten because they were too tightly coupled, difficult to extend and maintain. I suggest you to start with new version. Those of you who are in the middle of development and cannot just start from scratch, please let me know I will try to do my best to help. About Hi, I am Vadym . I made a lot of efforts creating Runtime Editor but this was interesting and rewarding experience. First version of Runtime editor was released in June 2016 and was pretty simplistic. Current version is much more sophisticated but in the same time much more flexible and contains a lot of useful features. If you have any questions or suggestions send an email to Battlehub@outlook.com or join this support group . I hope you will enjoy using Runtime Editor and it will be helpful.","title":"General"},{"location":"general/#introduction","text":"This documentation covers most important parts of Runtime Editor. Unlike previous versions of the documentation, I tried to concentrate more on examples rather then documenting each property of each script. Let me know what examples you would like to see. Start with following sections: Getting Started with Transform Handles Getting Started with Runtime Editor Getting Started with Save & Load Expose To Editor Event methods IOC Runtime Selection Runtime Undo","title":"Introduction"},{"location":"general/#list-of-features","text":"Position, Rotation, Scale Handles. Grid, Box Selection, Scene Gizmo. Transform Handles mobile & Google AR Core support. Global & Local coordinates, Local & Center pivot point modes, Vertex & Grid snapping. Gizmos for Colliders, Lights and Audio Sources. Scene navigation, Orthographic & Perspective view. Undo & Redo API. Object selection API. Object life-cycle Events. Play & Edit mode. Configurable Inspector . Component & Material editors. 16 Built-in property editors. Add Component control. Multiple Scenes and Cameras support. Dock Panels & Windows Management. Dialogs, Message Boxes, Confirmations. Easy to extend with new windows. Configurable Main & Context menu . Fast Virtualizing Tree View for Hierarchy and Project windows. Configurable Save & Load subsystem (almost no coding is required). Easy to use Project API . Static Assets, Asset Bundles and Dynamic Assets support . Load assets on demand. Multiple Projects support.","title":"List of Features"},{"location":"general/#upgrade-note","text":"Many breaking changes have been made since version 1.3.2u3. Runtime Save Load and some other parts were completely rewritten because they were too tightly coupled, difficult to extend and maintain. I suggest you to start with new version. Those of you who are in the middle of development and cannot just start from scratch, please let me know I will try to do my best to help.","title":"Upgrade note"},{"location":"general/#about","text":"Hi, I am Vadym . I made a lot of efforts creating Runtime Editor but this was interesting and rewarding experience. First version of Runtime editor was released in June 2016 and was pretty simplistic. Current version is much more sophisticated but in the same time much more flexible and contains a lot of useful features. If you have any questions or suggestions send an email to Battlehub@outlook.com or join this support group . I hope you will enjoy using Runtime Editor and it will be helpful.","title":"About"},{"location":"gizmos/","text":"Gizmos Docs Overview Runtime Gizmos are the runtime 3D controls that are used to manipulate items in the scene. Unlike transform handles , gizmos does not modify transformation of objects. They are used to modify colliders, bounding boxes and properties of light and audio sources instead. All gizmos, their base classes, rendering classes and shaders can be found in Assets/Battlehub/RTGizmos folder. Note Runtime Gizmos are simply referred as gizmos through this text Getting Started Here are several simple steps to get started with gizmos: Create Cube Create->3D Object->Cube Select Cube. Add Assets/Battlehub/RTGizmos/ BoxColliderGizmo component. Hit Play. Use mouse left-click + drag to resize Box Collider Gizmo. Observe that Center and Size properties of Box Collider were changed. Base Gizmo Source code of Base Gizmo can be found in Assets/Battlehub/RTGizmos/Scripts/ BaseGizmo.cs . This is the base class of Box Gizmo , Sphere Gizmo , Capsule Gizmo and Cone Gizmo . Therefore all these gizmos have following settings: Grid Size \u2013 step size used in unit snapping mode (default: 1.0). Line Color \u2013 color of line. Handles Color \u2013 color of handle (small quad). Selection Color \u2013 color of selected handle. Enable Undo \u2013 if set to true then gizmo will write all changes to undo stack (default: true). Unit Snap Key \u2013 key switching gizmo to unit snapping mode. Target \u2013 reference to the target object; Box Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ BoxGizmo.cs . Base class for all gizmos that have box shape: Box Collider Gizmo Skinned Mesh Renderer Gizmo Sphere Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ SphereGizmo.cs . Base class for all gizmos that have sphere shape: Sphere Collider Gizmo Pointlight Gizmo Audio Source Gizmo Audio Reverb Zone Gizmo Capsule Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ CapsuleGizmo.cs . Base class for all gizmos that have capsule shape: Capsule Collider Gizmo Cone Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ ConeGizmo.cs . Base class for all gizmos that have cone shape: Spotlight Gizmo Box Collider Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ BoxColliderGizmo.cs . Box Collider Gizmo could be added to object with Box Collider: Create Game Object with Box Collider. Add Box Collider Gizmo component. Sphere Collider Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ SphereColliderGizmo.cs . Sphere Collider Gizmo could be added to object with Sphere Collider: Create Game Object with Sphere Collider. Add Sphere Collider Gizmo component. Capsule Collider Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ CapsuleColliderGizmo.cs . Capsule Collider Gizmo could be added to object with Capsule Collider: Create Game Object with Capsule Collider. Add Capsule Collider Gizmo component. Point Light Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ PointLightGizmo.cs . Point Light Gizmo could be added to Point Light: Create Point Light. Add LightGizmo component. Spot Light Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ SpotLightGizmo.cs . Spot Light Gizmo could be added to Spot Light: Create Spot Light. Add LightGizmo component. Directional Light Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ DirectionalLightGizmo.cs . Directional Light Gizmo could be added to Directional Light Create Directional Light. Add Light Gizmo component. Audio Source Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ AudioSourceGizmo.cs . Audio Source Gizmo could be added to Audio Source Create Audio Source. Add Audio Source Gizmo component. Audio Reverb Zone Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ AudioReverbZoneGizmo.cs . Same as AudioSouce Gizmo Skinned Mesh Renderer Gizmo Located in Assets/Battlehub/RTGizmos/Scripts/ SkinnedMeshRendererGizmo.cs . Skinned Mesh Renderer Gizmo could be added to object with SkinnedMesh Create GameObject with SkinnedMeshRenderer. Add Skinned Mesh Renderer Gizmo component.","title":"Gizmos"},{"location":"gizmos/#gizmos-docs","text":"","title":"Gizmos Docs"},{"location":"gizmos/#overview","text":"Runtime Gizmos are the runtime 3D controls that are used to manipulate items in the scene. Unlike transform handles , gizmos does not modify transformation of objects. They are used to modify colliders, bounding boxes and properties of light and audio sources instead. All gizmos, their base classes, rendering classes and shaders can be found in Assets/Battlehub/RTGizmos folder. Note Runtime Gizmos are simply referred as gizmos through this text","title":"Overview"},{"location":"gizmos/#getting-started","text":"Here are several simple steps to get started with gizmos: Create Cube Create->3D Object->Cube Select Cube. Add Assets/Battlehub/RTGizmos/ BoxColliderGizmo component. Hit Play. Use mouse left-click + drag to resize Box Collider Gizmo. Observe that Center and Size properties of Box Collider were changed.","title":"Getting Started"},{"location":"gizmos/#base-gizmo","text":"Source code of Base Gizmo can be found in Assets/Battlehub/RTGizmos/Scripts/ BaseGizmo.cs . This is the base class of Box Gizmo , Sphere Gizmo , Capsule Gizmo and Cone Gizmo . Therefore all these gizmos have following settings: Grid Size \u2013 step size used in unit snapping mode (default: 1.0). Line Color \u2013 color of line. Handles Color \u2013 color of handle (small quad). Selection Color \u2013 color of selected handle. Enable Undo \u2013 if set to true then gizmo will write all changes to undo stack (default: true). Unit Snap Key \u2013 key switching gizmo to unit snapping mode. Target \u2013 reference to the target object;","title":"Base Gizmo"},{"location":"gizmos/#box-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ BoxGizmo.cs . Base class for all gizmos that have box shape: Box Collider Gizmo Skinned Mesh Renderer Gizmo","title":"Box Gizmo"},{"location":"gizmos/#sphere-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ SphereGizmo.cs . Base class for all gizmos that have sphere shape: Sphere Collider Gizmo Pointlight Gizmo Audio Source Gizmo Audio Reverb Zone Gizmo","title":"Sphere Gizmo"},{"location":"gizmos/#capsule-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ CapsuleGizmo.cs . Base class for all gizmos that have capsule shape: Capsule Collider Gizmo","title":"Capsule Gizmo"},{"location":"gizmos/#cone-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ ConeGizmo.cs . Base class for all gizmos that have cone shape: Spotlight Gizmo","title":"Cone Gizmo"},{"location":"gizmos/#box-collider-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ BoxColliderGizmo.cs . Box Collider Gizmo could be added to object with Box Collider: Create Game Object with Box Collider. Add Box Collider Gizmo component.","title":"Box Collider Gizmo"},{"location":"gizmos/#sphere-collider-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ SphereColliderGizmo.cs . Sphere Collider Gizmo could be added to object with Sphere Collider: Create Game Object with Sphere Collider. Add Sphere Collider Gizmo component.","title":"Sphere Collider Gizmo"},{"location":"gizmos/#capsule-collider-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ CapsuleColliderGizmo.cs . Capsule Collider Gizmo could be added to object with Capsule Collider: Create Game Object with Capsule Collider. Add Capsule Collider Gizmo component.","title":"Capsule Collider Gizmo"},{"location":"gizmos/#point-light-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ PointLightGizmo.cs . Point Light Gizmo could be added to Point Light: Create Point Light. Add LightGizmo component.","title":"Point Light Gizmo"},{"location":"gizmos/#spot-light-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ SpotLightGizmo.cs . Spot Light Gizmo could be added to Spot Light: Create Spot Light. Add LightGizmo component.","title":"Spot Light Gizmo"},{"location":"gizmos/#directional-light-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ DirectionalLightGizmo.cs . Directional Light Gizmo could be added to Directional Light Create Directional Light. Add Light Gizmo component.","title":"Directional Light Gizmo"},{"location":"gizmos/#audio-source-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ AudioSourceGizmo.cs . Audio Source Gizmo could be added to Audio Source Create Audio Source. Add Audio Source Gizmo component.","title":"Audio Source Gizmo"},{"location":"gizmos/#audio-reverb-zone-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ AudioReverbZoneGizmo.cs . Same as AudioSouce Gizmo","title":"Audio Reverb Zone Gizmo"},{"location":"gizmos/#skinned-mesh-renderer-gizmo","text":"Located in Assets/Battlehub/RTGizmos/Scripts/ SkinnedMeshRendererGizmo.cs . Skinned Mesh Renderer Gizmo could be added to object with SkinnedMesh Create GameObject with SkinnedMeshRenderer. Add Skinned Mesh Renderer Gizmo component.","title":"Skinned Mesh Renderer Gizmo"},{"location":"infrastructure/","text":"Common Infrastructure Docs Overview Common infrastructure classes and interfaces form core api of runtime editor. Among other there are selection , object lifecycle , tools , undo-redo and drag&drop API's. Expose To Editor Add Assets/Battlehub/RTCommon/Scripts/ ExposeToEditor component to any Game Object you want to make available for selection and editing. UnityEvents: Selected Event raised when object added to Runtime Selection . Unselected Event raised when object removed from Runtime Selection . Fields & Properties: AddColliders \u2013 add colliders to enable selection? (default: true). Bounds Object \u2013 reference to GameObject which will be used to draw Selection Gizmo . Custom Bounds \u2013 used if BoundsType == Custom. Bounds Type : Mesh \u2013 MeshFilter.mesh.bounds will be used to draw Selection Gizmo . SkinnedMesh \u2013 SkinnedMeshRenderer.mesh.bounds will be used to draw Selection Gizmo . Custom \u2013 user defined bounds. Any \u2013 any of the above. Event methods Event methods are called for all scripts of game objects with the Expose To Editor component attached. Note RuntimeAwake, RuntimeStart, OnRuntimeDestroy, OnRuntimeActivate, OnRuntimeDeactivate are called in play mode only. See IsPlaying property of IRTE interface using UnityEngine; public class ScriptEventsExample : MonoBehaviour { private void RuntimeAwake() { Debug.Log(\"Awake in play mode\"); } private void RuntimeStart() { Debug.Log(\"Start in play mode\"); } private void OnRuntimeDestroy() { Debug.Log(\"Destroy in play mode\"); } private void OnRuntimeActivate() { Debug.Log(\"Game View activated\"); } private void OnRuntimeDeactivate() { Debug.Log(\"Game View deactivated\"); } private void OnRuntimeEditorOpened() { Debug.Log(\"Editor Opened\"); } private void OnRuntimeEditorClosed() { Debug.Log(\"Editor Closed\"); } } IOC Assets/Battlehub/RTCommon/Scripts/Utis/ IOC is used for implementing simple dependency injection. Methods: static T Resolve<T>() - resolve dependency of type 'T' static void Register<T>(Func<T> func) - register construction function. static void Register<T>(T instance) - register instance. static void Unregister<T>(Func<T> func) - unregister construction function. static void Register<T>(T instance) - unregister instance. Example 1: using UnityEditor; using Battlehub.RTCommon; public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { void Awake() { IOC.Register<IDependency>(this); } } public class User : MonoBehaviour { void Start() { IDependency dependency = IOC.Resolve<IDependency>(); } } Example 2: using UnityEditor; using Battlehub.RTCommon; [DefaultExecutionOrder(-1)] public class Registrar : MonoBehaviour { void Awake() { IOC.Register<IDependency>( () => { GameObject go = new GameObject(); return go.AddComponent<Dependency>(); }); } } public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { } public class User : MonoBehaviour { void Awake() { IDependency dependency = IOC.Resolve<IDependency>(); } } IRTE interface Core editor functions and APIs are accessible through IRTE interface. This interface defined in Assets/Battlehub/RTCommon/Scripts/ RTEBase.cs Properties: CameraLayerSettings CameraLayerSettings { get; } - layers used by Runtime Graphics Layer . IInput Input { get; } - low level input . IRuntimeSelection Selection { get; } - selection functionality. IRuntimeUndo Undo { get; } - undo redo functionality. RuntimeTools Tools { get; } - tools functionality. CursorHelper CursorHelper { get; } - cursor helper. IRuntimeObjects Object { get; } - object lifecycle events. IDragDrop DragDrop { get; } - drag and drop functions. bool IsOpened { get; set; } - is editor opened? bool IsBusy { get; set; } - is editor busy? blocks user input. bool IsPlaymodeStateChanging { get; } - is editor either in play mode, or about to switch to it? bool IsPlaying { get; set; } - is editor currently in play mode? bool IsApplicationPaused { get; } - is application paused? Transform Root { get; } - editor root transform. RuntimeWindow ActiveWindow { get; } - currently active window . RuntimeWindow[] Windows { get; } - all registered windows. Methods: void ActivateWindow(RuntimeWindow window); - active window and associated RTE Components will receive user input. void RegisterCreatedObjects(GameObject[] go); - register created game objects to undo stack. void Duplicate(GameObject[] go); - duplicate objects and register created duplicates to undo stack. void Delete(GameObject[] go); - delete game objects and register this operation to undo stack. Events: RTEEvent PlaymodeStateChanging - raised before play mode change. RTEEvent PlaymodeStateChanged - raised when play mode state changed. RTEEvent ActiveWindowChanged - raised when window activated. RTEEvent<RuntimeWindow> WindowRegistered - raised when window registered. RTEEvent<RuntimeWindow> WindowUnregistered - raised when window unregistered. RTEEvent IsOpenedChanged - raised when IsOpened property changed. Here is how to get reference to IRTE : using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IRTE editor = IOC.Resolve<IRTE>(); } } Open and play example: using UnityEngine; using Battlehub.RTCommon; public class OpenAndPlay : MonoBehaviour { void Awake() { IRTE rte = IOC.Resolve<IRTE>(); rte.IsOpened = true; rte.IsPlaying = true; } } Lock user input example: using UnityEngine; using System.Collections; using Battlehub.RTCommon; public class BlockUserInput : MonoBehaviour { IRTE m_rte; void Start() { m_rte = IOC.Resolve<IRTE>(); StartCoroutine(DummyOperation()); } IEnumerator DummyOperation() { yield return new WaitWhile(() => m_rte.IsBusy); m_rte.IsBusy = true; Debug.Log(\"User input locked\"); yield return new WaitForSeconds(5); m_rte.IsBusy = false; Debug.Log(\"User input unlocked\"); } } Input Runtime editor , transform handels and gizmos are using IInput interface to access user input. Here is how to get reference to IInput: using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IInput input = IOC.Resolve<IRTE>().Input; } } IInput has following methods: bool IsAnyKeyDown() float GetAxis(InputAxis axisType) bool GetKeyDown(KeyCode key) bool GetKeyUp(KeyCode key) bool GetKey(KeyCode key) Vector3 GetPointerXY(int pointer) bool GetPointerDown(int button) bool GetPointerUp(int button) bool GetPointer(int button) RTE Component Assets/Battlehub/RTCommon/Scripts/ RTEComponent is the base class for all transform handles and gizmos . It hold reference to runtime window and check if this window is in active state. Runtime Selection IRuntimeSelection interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeSelection.cs . Here is how subscribe to SelectionChanged event and select object: using UnityEditor; using Battlehub.RTCommon; public class SelectObjectBehaviour : MonoBehaviour { IRuntimeSelection m_selection; void Start() { m_selection = IOC.Resolve<IRTE>().Selection; m_selection.SelectionChanged += OnSelectionChanged; GameObject go = new GameObject(); go.AddComponent<ExposeToEditor>(); m_selection.activeObject = go; } void OnDestroy() { if(m_selection != null) { m_selection.SelectionChanged -= OnSelectionChanged; } } void OnSelectionChanged(Object[] unselectedObjects) { if(unselectedObjects != null) { for(int i = 0; i < unselectedObjects.Length; ++i) { Object unselected = unselectedObjects[i]; Debug.Log(unselected); } } if(m_selection.objects != null) { for(int i = 0; i < m_selection.objects.Length; ++i) { Object selected = m_selection.objects[i]; Debug.Log(selected); } } } Runtime Objects IRuntimeObjects interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeObjects.cs . It can be used to track lifecycle events of objects exposed to editor. Methods: IEnumerable<ExposeToEditor> Get(bool rootsOnly, bool useCache = true) - call this method to get exposed to editor objects. If rootsOnly parameter set to false it return all objects, otherwise it return objects without parent. If useCache parameter set to false , then full traversal of object tree will be used. Events: event ObjectEvent Awaked - see corresponding MonoBehaviour event . event ObjectEvent Started - see corresponding MonoBehaviour event . event ObjectEvent Enabled - see corresponding MonoBehaviour event . event ObjectEvent Disabled - see corresponding MonoBehaviour event . event ObjectEvent Destroyed - see corresponding MonoBehaviour event . event ObjectEvent Destroying - raised just before Destroyed event. event ObjectEvent MarkAsDestroyedChanged - raised when object marked as destroyed by undo&redo event ObjectEvent MarkAsDestroyedChanging - raised just before MarkAsDestroyedChanged event. event ObjectEvent TransformChanged - position, rotation or localScale changed. event ObjectParentChangedEvent ParentChanged - transform.parent changed. event ObjectEvent NameChanged - object name changed. event ObjectEvent<Component> ComponentAdded - raised when new component added. Example: using Battlehub.RTCommon; using UnityEngine; public class ListenAwakeEvent : MonoBehaviour { IRuntimeObjects m_object; void Start() { m_object = IOC.Resolve<IRTE>().Object; m_object.Awaked += OnObjectAwaked; GameObject go = new GameObject(); go.AddComponent<ExposeToEditor>(); } void OnDestroy() { if(m_object != null) { m_object.Awaked -= OnObjectAwaked; } } void OnObjectAwaked(ExposeToEditor obj) { Debug.Log(obj); } } Runtime Tools RuntimeTools class can be found in Assets/Battlehub/RTCommon/Scripts/ RuntimeObjects.cs . Properties: LockObject LockAxes - this object hold aggregated locking state of selected objects. UnityObject ActiveTool - reference to active transform handle or gizmo. Active means that user is currently interacting with it. RuntimeTool Current - The tool that is currently selected for the Scene View: None Move Rotate Scale View RuntimePivotMode PivotMode - Are we in Center or Pivot mode. RuntimePivotRotation PivotRotation - What's the rotation of the tool handle: Global Local If property change, corresponding event is raised: event RuntimeToolsEvent ToolChanged event RuntimeToolsEvent PivotRotationChanged event RuntimeToolsEvent PivotModeChanged event RuntimeToolsEvent LockAxesChanged Here is how to change current tool: using UnityEditor; using Battlehub.RTCommon; public class SwitchToolBehaviour : MonoBehaviour { void Start() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.Current = RuntimeTool.Rotate; } } Here is how to lock axes for all selected objects: using UnityEditor; using Battlehub.RTCommon; public class LockAxesForAllObjects : MonoBehaviour { IRTE m_editor; void Start() { m_editor = IOC.Resolve<IRTE>(); m_editor.Selection.SelectionChanged += OnSelectionChanged; m_editor.Tools.ToolChanged += OnToolChanged; } void OnDestroy() { if(m_editor != null) { m_editor.Selection.SelectionChanged -= OnSelectionChanged; m_editor.Tools.ToolChanged -= OnToolChanged; } } void OnToolChanged() { Lock(); } void OnSelectionChanged(Object[] unselectedObjects) { Lock(); } static void Lock() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.LockAxes = new LockObject { PositionY = true, RotationX = true, RotationZ = true }; } } Runtime Undo IRuntimeUndo interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeUndo.cs . It is used to record changes, maintain undo/redo stack and perform undo and redo operations. Properties: bool Enabled { get; set; } - is undo & redo enabled? bool CanUndo { get; } - can undo? bool CanRedo { get; } - can redo? bool IsRecording { get; } - are we recording multiple changes? Methods: void BeginRecord() - begin record multiple changes. void EndRecord() - end record multiple changes. void RegisterCreatedObjects(ExposeToEditor[] createdObjects) - register created objects. void DestroyObjects(ExposeToEditor[] destoryedObjects) - register destroy objects operation. void BeginRecordValue(object target, MemberInfo memberInfo) - begin record value. void EndRecordValue(object target, MemberInfo memberInfo) - end record value. void BeginRecordTransform(Transform target) - begin record transform. void EndRecordTransform(Transform target) - end record transform. void AddComponent(ExposeToEditor obj, Type type) - add component and push corresponding record to the stack. void DestroyComponent(Component destroy, MemberInfo[] memberInfo) - destroy component and push corresponding record to the stack. void Redo() - redo. void Undo() - undo. void Purge() - purge all records. All \u201cmarked as destroyed\u201d objects will be destroyed. void Erase(object oldRef, object newRef) - replace oldRef with newRef for all records in stack. void Store() - create new stack and store current undo&redo stack. void Restore() - restore previously stored stack. Events: event RuntimeUndoEventHandler BeforeUndo - raised before undo operation. event RuntimeUndoEventHandler UndoCompleted - raised after undo operation. event RuntimeUndoEventHandler BeforeRedo - raised before redo operation. event RuntimeUndoEventHandler RedoCompleted - raised after redo operation. event RuntimeUndoEventHandler StateChanged - raised whenever one of the following operations performed: Store Restore Purge Here is how to record value and then undo changes: using UnityEditor; using Battlehub.RTCommon; public class RecordValueThenUndoChanges : MonoBehaviour { IRuntimeUndo m_undo; [SerializeField] int m_value = 1; void Start() { m_undo = IOC.Resolve<IRTE>().Undo; m_undo.UndoCompleted += OnUndoCompleted; MemberInfo valueInfo = Strong.MemberInfo((RecordValueThenUndoChanges x) => x.m_value); m_undo.BeginRecordValue(this, valueInfo); m_value = 2; m_undo.EndRecordValue(this, valueInfo); m_undo.Undo(); } void OnDestroy() { if (m_undo != null) { m_undo.UndoCompleted -= OnUndoCompleted; } } void OnUndoCompleted() { Debug.Log(m_value); //1 } } Drag And Drop IDragDrop interface defined in Assets/Battlehub/RTCommon/Scripts/ DragDrop.cs . It is used as a common interface for all drag & drop operations. Properties: object[] DragObjects { get; } - objects being dragged. object Source { get; } - drag & drop operation source object. bool InProgress { get; } - is drag and drop in progress? Methods: void Reset() - cancel current drag & drop operation. void SetCursor(KnownCursor cursorType) - set cursor. KnownCursor.DropNowAllowed KnownCursor.DropAllowed void RaiseBeginDrag(object source, object[] dragItems, PointerEventData pointerEventData) - begin drag & drop. void RaiseDrag(PointerEventData eventData) - drag. void RaiseDrop(PointerEventData pointerEventData) - end drag & drop. Events: event DragDropEventHander BeginDrag - raised by RaiseBeginDrag method. event DragDropEventHander Drag - raised by RaiseDrag method. event DragDropEventHander Drop - raised by RaiseDrop method. In this example we will handle Drag Drop operation into console window: using Battlehub.RTCommon; using UnityEngine; using UnityEngine.EventSystems; public class ConsoleDragDropHandler : MonoBehaviour { IDragDrop m_dragDrop; RuntimeWindow m_target; void Start() { m_target = IOC.Resolve<IRTE>().GetWindow(RuntimeWindowType.Console); m_dragDrop = IOC.Resolve<IRTE>().DragDrop; m_dragDrop.Drop += OnDrop; } void OnDestroy() { if(m_dragDrop != null) { m_dragDrop.Drop -= OnDrop; } } void OnDrop(PointerEventData pointerEventData) { if(m_target != null && m_target.IsPointerOver) { Debug.Log(m_dragDrop.DragObjects[0]); } } } Runtime Window RuntimeWindow class can be found in Assets/Battlehub/RTCommon/Scripts/ RuntimeWindow.cs . If you want to extend Runtime Editor with new windows, then they must be inherited from Runtime Window class. Here is how to do it: using Battlehub.RTCommon; using Battlehub.Utils; using UnityEngine; using UnityEngine.EventSystems; public class CustomWindow : RuntimeWindow { protected override void AwakeOverride() { WindowType = RuntimeWindowType.Custom; base.AwakeOverride(); } protected override void OnDestroyOverride() { base.OnDestroyOverride(); } protected override void OnActivated() { base.OnActivated(); Debug.Log(\"On Custom Window Activated\"); } protected override void OnDeactivated() { base.OnDeactivated(); Debug.Log(\"On Custom Window Deactivated\"); } public override void DragEnter(object[] dragObjects, PointerEventData eventData) { base.DragEnter(dragObjects, eventData); Editor.DragDrop.SetCursor(KnownCursor.DropAllowed); Debug.Log(\"On Drag Enter\"); } public override void DragLeave(PointerEventData eventData) { base.DragLeave(eventData); Editor.DragDrop.SetCursor(KnownCursor.DropNowAllowed); Debug.Log(\"On Drag Leave\"); } public override void Drop(object[] dragObjects, PointerEventData eventData) { base.Drop(dragObjects, eventData); Debug.Log(\"On Drop\"); for(int i = 0; i < dragObjects.Length; ++i) { Debug.Log(dragObjects[i]); } } } Note For information on how to register custom window please proceed to -> this <- section","title":"Common Infrastructure"},{"location":"infrastructure/#common-infrastructure-docs","text":"","title":"Common Infrastructure Docs"},{"location":"infrastructure/#overview","text":"Common infrastructure classes and interfaces form core api of runtime editor. Among other there are selection , object lifecycle , tools , undo-redo and drag&drop API's.","title":"Overview"},{"location":"infrastructure/#expose-to-editor","text":"Add Assets/Battlehub/RTCommon/Scripts/ ExposeToEditor component to any Game Object you want to make available for selection and editing. UnityEvents: Selected Event raised when object added to Runtime Selection . Unselected Event raised when object removed from Runtime Selection . Fields & Properties: AddColliders \u2013 add colliders to enable selection? (default: true). Bounds Object \u2013 reference to GameObject which will be used to draw Selection Gizmo . Custom Bounds \u2013 used if BoundsType == Custom. Bounds Type : Mesh \u2013 MeshFilter.mesh.bounds will be used to draw Selection Gizmo . SkinnedMesh \u2013 SkinnedMeshRenderer.mesh.bounds will be used to draw Selection Gizmo . Custom \u2013 user defined bounds. Any \u2013 any of the above.","title":"Expose To Editor"},{"location":"infrastructure/#event-methods","text":"Event methods are called for all scripts of game objects with the Expose To Editor component attached. Note RuntimeAwake, RuntimeStart, OnRuntimeDestroy, OnRuntimeActivate, OnRuntimeDeactivate are called in play mode only. See IsPlaying property of IRTE interface using UnityEngine; public class ScriptEventsExample : MonoBehaviour { private void RuntimeAwake() { Debug.Log(\"Awake in play mode\"); } private void RuntimeStart() { Debug.Log(\"Start in play mode\"); } private void OnRuntimeDestroy() { Debug.Log(\"Destroy in play mode\"); } private void OnRuntimeActivate() { Debug.Log(\"Game View activated\"); } private void OnRuntimeDeactivate() { Debug.Log(\"Game View deactivated\"); } private void OnRuntimeEditorOpened() { Debug.Log(\"Editor Opened\"); } private void OnRuntimeEditorClosed() { Debug.Log(\"Editor Closed\"); } }","title":"Event methods"},{"location":"infrastructure/#ioc","text":"Assets/Battlehub/RTCommon/Scripts/Utis/ IOC is used for implementing simple dependency injection. Methods: static T Resolve<T>() - resolve dependency of type 'T' static void Register<T>(Func<T> func) - register construction function. static void Register<T>(T instance) - register instance. static void Unregister<T>(Func<T> func) - unregister construction function. static void Register<T>(T instance) - unregister instance. Example 1: using UnityEditor; using Battlehub.RTCommon; public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { void Awake() { IOC.Register<IDependency>(this); } } public class User : MonoBehaviour { void Start() { IDependency dependency = IOC.Resolve<IDependency>(); } } Example 2: using UnityEditor; using Battlehub.RTCommon; [DefaultExecutionOrder(-1)] public class Registrar : MonoBehaviour { void Awake() { IOC.Register<IDependency>( () => { GameObject go = new GameObject(); return go.AddComponent<Dependency>(); }); } } public interface IDependency { } public class Dependency : MonoBehaviour, IDependency { } public class User : MonoBehaviour { void Awake() { IDependency dependency = IOC.Resolve<IDependency>(); } }","title":"IOC"},{"location":"infrastructure/#irte-interface","text":"Core editor functions and APIs are accessible through IRTE interface. This interface defined in Assets/Battlehub/RTCommon/Scripts/ RTEBase.cs Properties: CameraLayerSettings CameraLayerSettings { get; } - layers used by Runtime Graphics Layer . IInput Input { get; } - low level input . IRuntimeSelection Selection { get; } - selection functionality. IRuntimeUndo Undo { get; } - undo redo functionality. RuntimeTools Tools { get; } - tools functionality. CursorHelper CursorHelper { get; } - cursor helper. IRuntimeObjects Object { get; } - object lifecycle events. IDragDrop DragDrop { get; } - drag and drop functions. bool IsOpened { get; set; } - is editor opened? bool IsBusy { get; set; } - is editor busy? blocks user input. bool IsPlaymodeStateChanging { get; } - is editor either in play mode, or about to switch to it? bool IsPlaying { get; set; } - is editor currently in play mode? bool IsApplicationPaused { get; } - is application paused? Transform Root { get; } - editor root transform. RuntimeWindow ActiveWindow { get; } - currently active window . RuntimeWindow[] Windows { get; } - all registered windows. Methods: void ActivateWindow(RuntimeWindow window); - active window and associated RTE Components will receive user input. void RegisterCreatedObjects(GameObject[] go); - register created game objects to undo stack. void Duplicate(GameObject[] go); - duplicate objects and register created duplicates to undo stack. void Delete(GameObject[] go); - delete game objects and register this operation to undo stack. Events: RTEEvent PlaymodeStateChanging - raised before play mode change. RTEEvent PlaymodeStateChanged - raised when play mode state changed. RTEEvent ActiveWindowChanged - raised when window activated. RTEEvent<RuntimeWindow> WindowRegistered - raised when window registered. RTEEvent<RuntimeWindow> WindowUnregistered - raised when window unregistered. RTEEvent IsOpenedChanged - raised when IsOpened property changed. Here is how to get reference to IRTE : using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IRTE editor = IOC.Resolve<IRTE>(); } } Open and play example: using UnityEngine; using Battlehub.RTCommon; public class OpenAndPlay : MonoBehaviour { void Awake() { IRTE rte = IOC.Resolve<IRTE>(); rte.IsOpened = true; rte.IsPlaying = true; } } Lock user input example: using UnityEngine; using System.Collections; using Battlehub.RTCommon; public class BlockUserInput : MonoBehaviour { IRTE m_rte; void Start() { m_rte = IOC.Resolve<IRTE>(); StartCoroutine(DummyOperation()); } IEnumerator DummyOperation() { yield return new WaitWhile(() => m_rte.IsBusy); m_rte.IsBusy = true; Debug.Log(\"User input locked\"); yield return new WaitForSeconds(5); m_rte.IsBusy = false; Debug.Log(\"User input unlocked\"); } }","title":"IRTE interface"},{"location":"infrastructure/#input","text":"Runtime editor , transform handels and gizmos are using IInput interface to access user input. Here is how to get reference to IInput: using UnityEngine; using Battlehub.RTCommon; public class GetIRTE : MonoBehaviour { void Awake() { IInput input = IOC.Resolve<IRTE>().Input; } } IInput has following methods: bool IsAnyKeyDown() float GetAxis(InputAxis axisType) bool GetKeyDown(KeyCode key) bool GetKeyUp(KeyCode key) bool GetKey(KeyCode key) Vector3 GetPointerXY(int pointer) bool GetPointerDown(int button) bool GetPointerUp(int button) bool GetPointer(int button)","title":"Input"},{"location":"infrastructure/#rte-component","text":"Assets/Battlehub/RTCommon/Scripts/ RTEComponent is the base class for all transform handles and gizmos . It hold reference to runtime window and check if this window is in active state.","title":"RTE Component"},{"location":"infrastructure/#runtime-selection","text":"IRuntimeSelection interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeSelection.cs . Here is how subscribe to SelectionChanged event and select object: using UnityEditor; using Battlehub.RTCommon; public class SelectObjectBehaviour : MonoBehaviour { IRuntimeSelection m_selection; void Start() { m_selection = IOC.Resolve<IRTE>().Selection; m_selection.SelectionChanged += OnSelectionChanged; GameObject go = new GameObject(); go.AddComponent<ExposeToEditor>(); m_selection.activeObject = go; } void OnDestroy() { if(m_selection != null) { m_selection.SelectionChanged -= OnSelectionChanged; } } void OnSelectionChanged(Object[] unselectedObjects) { if(unselectedObjects != null) { for(int i = 0; i < unselectedObjects.Length; ++i) { Object unselected = unselectedObjects[i]; Debug.Log(unselected); } } if(m_selection.objects != null) { for(int i = 0; i < m_selection.objects.Length; ++i) { Object selected = m_selection.objects[i]; Debug.Log(selected); } } }","title":"Runtime Selection"},{"location":"infrastructure/#runtime-objects","text":"IRuntimeObjects interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeObjects.cs . It can be used to track lifecycle events of objects exposed to editor. Methods: IEnumerable<ExposeToEditor> Get(bool rootsOnly, bool useCache = true) - call this method to get exposed to editor objects. If rootsOnly parameter set to false it return all objects, otherwise it return objects without parent. If useCache parameter set to false , then full traversal of object tree will be used. Events: event ObjectEvent Awaked - see corresponding MonoBehaviour event . event ObjectEvent Started - see corresponding MonoBehaviour event . event ObjectEvent Enabled - see corresponding MonoBehaviour event . event ObjectEvent Disabled - see corresponding MonoBehaviour event . event ObjectEvent Destroyed - see corresponding MonoBehaviour event . event ObjectEvent Destroying - raised just before Destroyed event. event ObjectEvent MarkAsDestroyedChanged - raised when object marked as destroyed by undo&redo event ObjectEvent MarkAsDestroyedChanging - raised just before MarkAsDestroyedChanged event. event ObjectEvent TransformChanged - position, rotation or localScale changed. event ObjectParentChangedEvent ParentChanged - transform.parent changed. event ObjectEvent NameChanged - object name changed. event ObjectEvent<Component> ComponentAdded - raised when new component added. Example: using Battlehub.RTCommon; using UnityEngine; public class ListenAwakeEvent : MonoBehaviour { IRuntimeObjects m_object; void Start() { m_object = IOC.Resolve<IRTE>().Object; m_object.Awaked += OnObjectAwaked; GameObject go = new GameObject(); go.AddComponent<ExposeToEditor>(); } void OnDestroy() { if(m_object != null) { m_object.Awaked -= OnObjectAwaked; } } void OnObjectAwaked(ExposeToEditor obj) { Debug.Log(obj); } }","title":"Runtime Objects"},{"location":"infrastructure/#runtime-tools","text":"RuntimeTools class can be found in Assets/Battlehub/RTCommon/Scripts/ RuntimeObjects.cs . Properties: LockObject LockAxes - this object hold aggregated locking state of selected objects. UnityObject ActiveTool - reference to active transform handle or gizmo. Active means that user is currently interacting with it. RuntimeTool Current - The tool that is currently selected for the Scene View: None Move Rotate Scale View RuntimePivotMode PivotMode - Are we in Center or Pivot mode. RuntimePivotRotation PivotRotation - What's the rotation of the tool handle: Global Local If property change, corresponding event is raised: event RuntimeToolsEvent ToolChanged event RuntimeToolsEvent PivotRotationChanged event RuntimeToolsEvent PivotModeChanged event RuntimeToolsEvent LockAxesChanged Here is how to change current tool: using UnityEditor; using Battlehub.RTCommon; public class SwitchToolBehaviour : MonoBehaviour { void Start() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.Current = RuntimeTool.Rotate; } } Here is how to lock axes for all selected objects: using UnityEditor; using Battlehub.RTCommon; public class LockAxesForAllObjects : MonoBehaviour { IRTE m_editor; void Start() { m_editor = IOC.Resolve<IRTE>(); m_editor.Selection.SelectionChanged += OnSelectionChanged; m_editor.Tools.ToolChanged += OnToolChanged; } void OnDestroy() { if(m_editor != null) { m_editor.Selection.SelectionChanged -= OnSelectionChanged; m_editor.Tools.ToolChanged -= OnToolChanged; } } void OnToolChanged() { Lock(); } void OnSelectionChanged(Object[] unselectedObjects) { Lock(); } static void Lock() { IRTE editor = IOC.Resolve<IRTE>(); editor.Tools.LockAxes = new LockObject { PositionY = true, RotationX = true, RotationZ = true }; } }","title":"Runtime Tools"},{"location":"infrastructure/#runtime-undo","text":"IRuntimeUndo interface defined in Assets/Battlehub/RTCommon/Scripts/ RuntimeUndo.cs . It is used to record changes, maintain undo/redo stack and perform undo and redo operations. Properties: bool Enabled { get; set; } - is undo & redo enabled? bool CanUndo { get; } - can undo? bool CanRedo { get; } - can redo? bool IsRecording { get; } - are we recording multiple changes? Methods: void BeginRecord() - begin record multiple changes. void EndRecord() - end record multiple changes. void RegisterCreatedObjects(ExposeToEditor[] createdObjects) - register created objects. void DestroyObjects(ExposeToEditor[] destoryedObjects) - register destroy objects operation. void BeginRecordValue(object target, MemberInfo memberInfo) - begin record value. void EndRecordValue(object target, MemberInfo memberInfo) - end record value. void BeginRecordTransform(Transform target) - begin record transform. void EndRecordTransform(Transform target) - end record transform. void AddComponent(ExposeToEditor obj, Type type) - add component and push corresponding record to the stack. void DestroyComponent(Component destroy, MemberInfo[] memberInfo) - destroy component and push corresponding record to the stack. void Redo() - redo. void Undo() - undo. void Purge() - purge all records. All \u201cmarked as destroyed\u201d objects will be destroyed. void Erase(object oldRef, object newRef) - replace oldRef with newRef for all records in stack. void Store() - create new stack and store current undo&redo stack. void Restore() - restore previously stored stack. Events: event RuntimeUndoEventHandler BeforeUndo - raised before undo operation. event RuntimeUndoEventHandler UndoCompleted - raised after undo operation. event RuntimeUndoEventHandler BeforeRedo - raised before redo operation. event RuntimeUndoEventHandler RedoCompleted - raised after redo operation. event RuntimeUndoEventHandler StateChanged - raised whenever one of the following operations performed: Store Restore Purge Here is how to record value and then undo changes: using UnityEditor; using Battlehub.RTCommon; public class RecordValueThenUndoChanges : MonoBehaviour { IRuntimeUndo m_undo; [SerializeField] int m_value = 1; void Start() { m_undo = IOC.Resolve<IRTE>().Undo; m_undo.UndoCompleted += OnUndoCompleted; MemberInfo valueInfo = Strong.MemberInfo((RecordValueThenUndoChanges x) => x.m_value); m_undo.BeginRecordValue(this, valueInfo); m_value = 2; m_undo.EndRecordValue(this, valueInfo); m_undo.Undo(); } void OnDestroy() { if (m_undo != null) { m_undo.UndoCompleted -= OnUndoCompleted; } } void OnUndoCompleted() { Debug.Log(m_value); //1 } }","title":"Runtime Undo"},{"location":"infrastructure/#drag-and-drop","text":"IDragDrop interface defined in Assets/Battlehub/RTCommon/Scripts/ DragDrop.cs . It is used as a common interface for all drag & drop operations. Properties: object[] DragObjects { get; } - objects being dragged. object Source { get; } - drag & drop operation source object. bool InProgress { get; } - is drag and drop in progress? Methods: void Reset() - cancel current drag & drop operation. void SetCursor(KnownCursor cursorType) - set cursor. KnownCursor.DropNowAllowed KnownCursor.DropAllowed void RaiseBeginDrag(object source, object[] dragItems, PointerEventData pointerEventData) - begin drag & drop. void RaiseDrag(PointerEventData eventData) - drag. void RaiseDrop(PointerEventData pointerEventData) - end drag & drop. Events: event DragDropEventHander BeginDrag - raised by RaiseBeginDrag method. event DragDropEventHander Drag - raised by RaiseDrag method. event DragDropEventHander Drop - raised by RaiseDrop method. In this example we will handle Drag Drop operation into console window: using Battlehub.RTCommon; using UnityEngine; using UnityEngine.EventSystems; public class ConsoleDragDropHandler : MonoBehaviour { IDragDrop m_dragDrop; RuntimeWindow m_target; void Start() { m_target = IOC.Resolve<IRTE>().GetWindow(RuntimeWindowType.Console); m_dragDrop = IOC.Resolve<IRTE>().DragDrop; m_dragDrop.Drop += OnDrop; } void OnDestroy() { if(m_dragDrop != null) { m_dragDrop.Drop -= OnDrop; } } void OnDrop(PointerEventData pointerEventData) { if(m_target != null && m_target.IsPointerOver) { Debug.Log(m_dragDrop.DragObjects[0]); } } }","title":"Drag And Drop"},{"location":"infrastructure/#runtime-window","text":"RuntimeWindow class can be found in Assets/Battlehub/RTCommon/Scripts/ RuntimeWindow.cs . If you want to extend Runtime Editor with new windows, then they must be inherited from Runtime Window class. Here is how to do it: using Battlehub.RTCommon; using Battlehub.Utils; using UnityEngine; using UnityEngine.EventSystems; public class CustomWindow : RuntimeWindow { protected override void AwakeOverride() { WindowType = RuntimeWindowType.Custom; base.AwakeOverride(); } protected override void OnDestroyOverride() { base.OnDestroyOverride(); } protected override void OnActivated() { base.OnActivated(); Debug.Log(\"On Custom Window Activated\"); } protected override void OnDeactivated() { base.OnDeactivated(); Debug.Log(\"On Custom Window Deactivated\"); } public override void DragEnter(object[] dragObjects, PointerEventData eventData) { base.DragEnter(dragObjects, eventData); Editor.DragDrop.SetCursor(KnownCursor.DropAllowed); Debug.Log(\"On Drag Enter\"); } public override void DragLeave(PointerEventData eventData) { base.DragLeave(eventData); Editor.DragDrop.SetCursor(KnownCursor.DropNowAllowed); Debug.Log(\"On Drag Leave\"); } public override void Drop(object[] dragObjects, PointerEventData eventData) { base.Drop(dragObjects, eventData); Debug.Log(\"On Drop\"); for(int i = 0; i < dragObjects.Length; ++i) { Debug.Log(dragObjects[i]); } } } Note For information on how to register custom window please proceed to -> this <- section","title":"Runtime Window"},{"location":"menu-control/","text":"Menu Control Docs Overview The Menu control allows hierarchal organization of elements associated with commands. It can be used to implement main and context menu of an application. Getting Started Create Canvas Add MenuButton.prefab from Assets/Battelhub/UIControls/Menu/Prefabs to hierarchy. Add Menu.prefab from Assets/Battelhub/UIControls/Menu/Prefabs to hierarchy Set Menu field of the Menu Button: Create Empty Game Object and name it Command Handler Create MenuCmdHandler script and add it to the Command Handler : using UnityEngine; using Battlehub.UIControls.MenuControl; public class MenuCmdHandler : MonoBehaviour { public void OnValidateCmd(MenuItemValidationArgs args) { Debug.Log(\"Validate Command: \" + args.Command); if(args.Command == \"Item Cmd\") { args.IsValid = false; } } public void OnCmd(string cmd) { Debug.Log(\"Run Cmd: \" + cmd); } } Set Action and Validate event handlers of each entry in Items array of the Menu: Hit Play, open the Menu and click Child Item . You should see following output: Menu Item Structure: Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ MenuItem.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ MenuItem.cs Fields: Selection Color - highlighted color. Text Color - text color. Disabled Selection Color - highlighted color of disabled menu item. Disabled Text Color - text color of disabled menu item. Icon - image. Text - text. Expander - image visible if menu item has sub-menu. Selection - image visible when pointer is over menu item. Menu Structure: Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ Menu.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ Menu.cs Fields: Items - array of Menu Item Info. Menu Item Prefab - reference to menu item prefab. Anchor - opened menu will be aligned with anchor. Panel - parent of menu items. Canvas Group - required to \"fade-in\" menu. Fade in speed - how much the alpha property changes per second. [Serializable] public class MenuItemInfo { public string Path; //path to menu item e.g. Create/3DObject/Cube public string Text; //menu item text public Sprite Icon; //menu item icon public string Command; //argument passed to Action event handler and Validate event handler public MenuItemEvent Action; //raised when menu item clicked public MenuItemValidationEvent Validate; //event raised when menu opened } Main Menu Button This button can be used to open menu. It has three states: normal, pointer over and focused. The transition to the focused state occurs when the menu is opened. The transition to the normal state occurs when the menu is closed. Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ MenuButton.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ MenuButton.cs Context Menu Trigger This script opens the menu when you click the right mouse button. Script: Assets/Battelhub/UIControls/Menu/Scripts/ \u0421ontextMenuTrigger.cs","title":"Menu Control"},{"location":"menu-control/#menu-control-docs","text":"","title":"Menu Control Docs"},{"location":"menu-control/#overview","text":"The Menu control allows hierarchal organization of elements associated with commands. It can be used to implement main and context menu of an application.","title":"Overview"},{"location":"menu-control/#getting-started","text":"Create Canvas Add MenuButton.prefab from Assets/Battelhub/UIControls/Menu/Prefabs to hierarchy. Add Menu.prefab from Assets/Battelhub/UIControls/Menu/Prefabs to hierarchy Set Menu field of the Menu Button: Create Empty Game Object and name it Command Handler Create MenuCmdHandler script and add it to the Command Handler : using UnityEngine; using Battlehub.UIControls.MenuControl; public class MenuCmdHandler : MonoBehaviour { public void OnValidateCmd(MenuItemValidationArgs args) { Debug.Log(\"Validate Command: \" + args.Command); if(args.Command == \"Item Cmd\") { args.IsValid = false; } } public void OnCmd(string cmd) { Debug.Log(\"Run Cmd: \" + cmd); } } Set Action and Validate event handlers of each entry in Items array of the Menu: Hit Play, open the Menu and click Child Item . You should see following output:","title":"Getting Started"},{"location":"menu-control/#menu-item","text":"Structure: Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ MenuItem.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ MenuItem.cs Fields: Selection Color - highlighted color. Text Color - text color. Disabled Selection Color - highlighted color of disabled menu item. Disabled Text Color - text color of disabled menu item. Icon - image. Text - text. Expander - image visible if menu item has sub-menu. Selection - image visible when pointer is over menu item.","title":"Menu Item"},{"location":"menu-control/#menu","text":"Structure: Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ Menu.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ Menu.cs Fields: Items - array of Menu Item Info. Menu Item Prefab - reference to menu item prefab. Anchor - opened menu will be aligned with anchor. Panel - parent of menu items. Canvas Group - required to \"fade-in\" menu. Fade in speed - how much the alpha property changes per second. [Serializable] public class MenuItemInfo { public string Path; //path to menu item e.g. Create/3DObject/Cube public string Text; //menu item text public Sprite Icon; //menu item icon public string Command; //argument passed to Action event handler and Validate event handler public MenuItemEvent Action; //raised when menu item clicked public MenuItemValidationEvent Validate; //event raised when menu opened }","title":"Menu"},{"location":"menu-control/#main-menu-button","text":"This button can be used to open menu. It has three states: normal, pointer over and focused. The transition to the focused state occurs when the menu is opened. The transition to the normal state occurs when the menu is closed. Prefab: Assets/Battelhub/UIControls/Menu/Prefabs/ MenuButton.prefab Script: Assets/Battelhub/UIControls/Menu/Scripts/ MenuButton.cs","title":"Main Menu Button"},{"location":"menu-control/#context-menu-trigger","text":"This script opens the menu when you click the right mouse button. Script: Assets/Battelhub/UIControls/Menu/Scripts/ \u0421ontextMenuTrigger.cs","title":"Context Menu Trigger"},{"location":"rendering/","text":"Rendering Notes IGL All transform handles and gizmos implement IGL interface in order to be rendered in the scene namespace Battlehub.RTCommon { public interface IGL { void Draw(int cullingMask); } } GLRenderer Located in Assets/Battlehub/RTCommon/Scripts/Graphics/GLRenderer.cs , GLRenderer is a singleton used by GLCamera script to render all registered IGL objects. To register object for rendering call void Add(IGL gl) method. To cancel object rendering call void Remove(IGL gl) method. Here is how to create and register gizmo for rendering: namespace Battlehub.RTCommon { public class MyGizmo : MonoBehaviour, IGL { [SerializeField] private Material m_material; private void OnEnable() { if (GLRenderer.Instance != null) { GLRenderer.Instance.Add(this); } } private void OnDisable() { if (GLRenderer.Instance != null) { GLRenderer.Instance.Remove(this); } } private void Draw(int cullingMask) { m_material.SetPass(0); RuntimeGraphics.DrawQuad(transform.localToWorldMatrix); } } } Note It is possible that above code will not work with new scriptable rendering pipeline . In this case Runtime Graphics Layer will be used to draw gizmos in future versions . GLCamera Located in Assets/Battlehub/RTCommon/Scripts/Graphics/GLCamera.cs Add GLCamera component to Camera and it will render IGL objects . Runtime Graphics Layer Located in Assets/Battlehub/RTCommon/Scripts/Graphics/RuntimeGraphicsLayer.cs . This component is created automatically in case if position handle , rotation handle or scale handle has reference to corresponding model ( Model field is not null). This script will create Graphics Layer Camera parented to scene camera (main camera by default) and will set Clear Flags to the Depth only and Culling Mask to the RuntimeGraphicsLayer . At the same time RuntimeGraphicsLayer will be excluded from Culling Mask of scene camera. Transform handle models belong to RuntimeGraphicsLayer and therefore they will be renderer by Graphics Layer Camera only. Note Runtime Editor use 6 layers [19-24]: for ui, for asset previews and for runtime graphics.","title":"Rendering"},{"location":"rendering/#rendering-notes","text":"","title":"Rendering Notes"},{"location":"rendering/#igl","text":"All transform handles and gizmos implement IGL interface in order to be rendered in the scene namespace Battlehub.RTCommon { public interface IGL { void Draw(int cullingMask); } }","title":"IGL"},{"location":"rendering/#glrenderer","text":"Located in Assets/Battlehub/RTCommon/Scripts/Graphics/GLRenderer.cs , GLRenderer is a singleton used by GLCamera script to render all registered IGL objects. To register object for rendering call void Add(IGL gl) method. To cancel object rendering call void Remove(IGL gl) method. Here is how to create and register gizmo for rendering: namespace Battlehub.RTCommon { public class MyGizmo : MonoBehaviour, IGL { [SerializeField] private Material m_material; private void OnEnable() { if (GLRenderer.Instance != null) { GLRenderer.Instance.Add(this); } } private void OnDisable() { if (GLRenderer.Instance != null) { GLRenderer.Instance.Remove(this); } } private void Draw(int cullingMask) { m_material.SetPass(0); RuntimeGraphics.DrawQuad(transform.localToWorldMatrix); } } } Note It is possible that above code will not work with new scriptable rendering pipeline . In this case Runtime Graphics Layer will be used to draw gizmos in future versions .","title":"GLRenderer"},{"location":"rendering/#glcamera","text":"Located in Assets/Battlehub/RTCommon/Scripts/Graphics/GLCamera.cs Add GLCamera component to Camera and it will render IGL objects .","title":"GLCamera"},{"location":"rendering/#runtime-graphics-layer","text":"Located in Assets/Battlehub/RTCommon/Scripts/Graphics/RuntimeGraphicsLayer.cs . This component is created automatically in case if position handle , rotation handle or scale handle has reference to corresponding model ( Model field is not null). This script will create Graphics Layer Camera parented to scene camera (main camera by default) and will set Clear Flags to the Depth only and Culling Mask to the RuntimeGraphicsLayer . At the same time RuntimeGraphicsLayer will be excluded from Culling Mask of scene camera. Transform handle models belong to RuntimeGraphicsLayer and therefore they will be renderer by Graphics Layer Camera only. Note Runtime Editor use 6 layers [19-24]: for ui, for asset previews and for runtime graphics.","title":"Runtime Graphics Layer"},{"location":"runtime-editor/","text":"Runtime Editor Docs Overview Runtime Editor is the set of scripts and prefabs which help you to create scene editor, game level editor or build your own modeling application. It supports drag & drop , undo & redo and selection api. To implement user interface and core functions runtime editor use transform-handles , gizmos , save load subsystem and three controls: menu , virtualizing tree view and dock panels . Out of the box it has six Views: Scene View to manipulate objects in the scene. Hierarchy View for displaying and manipulating the object tree. Project View to manage assets and scenes. Inspector View to display and edit object properties. Console View to display information, warnings and errors. Game View for the game. Add More... The Runtime Editor has many ready-to-use property and component editors and it is relatively easy to create new ones . \"Add Component\" drop-down button allows you to add components at runtime. There are also several important dialogs included: Save Scene Dialog . Object Picker . Color Picker . Asset Bundles and Libraries Importer . Manage Projects Dialog . Getting Started To get started with Runtime Editor do following: Create new scene and save it. Click Tools->Runtime Editor->Create Add Battlehub/RTEditor/Scripts/ Game View Camera component to Main Camera Create several Game Objects and add Expose To Editor component. Click Tools->Runtime SaveLoad->Build All Hit Play Few more steps: Create Asset Library Launch runtime editor and click File->Import Assets . Select the built-in asset library created in step 1. Import assets. You will see the imported assets in the project window. Note Demo scene can be found in Assets/Battlehub/RTEditor/Demo Main & Context Menu Runtime Editor use Menu control to implement main and context-menu. To extend main menu create static class with [MenuDefinition] attribute and add static methods with [MenuCommand] attribute. using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; [MenuDefinition] public static class MyMenu { /// add new command to exising menu [MenuCommand(\"MenuWindow/Create My Window\")] public static void CreateMyWindow() { Debug.Log(\"Create My Window\"); } /// add new command to new menu [MenuCommand(\"My Menu/My Submenu/My Command\")] public static void CreateMyMenu() { Debug.Log(\"Create My Menu\"); } /// disable menu item [MenuCommand(\"My Menu/My Submenu/My Command\", validate: true)] public static bool ValidateMyCommand() { Debug.Log(\"Disable My Command\"); return false; } /// replace existing menu item [MenuCommand(\"MenuFile/Close\")] public static void Close() { Debug.Log(\"Intercepted\"); IRuntimeEditor rte = IOC.Resolve<IRuntimeEditor>(); rte.Close(); } /// Hide existing menu item [MenuCommand(\"MenuHelp/About RTE\", hide: true)] public static void HideAbout() { } } To open context menu with custom commands do following: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; public static class MyContextMenu { public static void OpenContextMenu() { IContextMenu contextMenu = IOC.Resolve<IContextMenu>(); MenuItemInfo cmd1 = new MenuItemInfo { Path = \"My Command 1\" }; cmd1.Action = new MenuItemEvent(); cmd1.Action.AddListener((args) => { Debug.Log(\"Run My Command1\"); IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); Debug.Log(editor.Selection.activeGameObject); }); MenuItemInfo cmd2 = new MenuItemInfo { Path = \"My Command 2\" }; cmd2.Validate = new MenuItemValidationEvent(); cmd2.Action = new MenuItemEvent(); cmd2.Validate.AddListener((args) => { args.IsValid = false; }); cmd2.Action.AddListener((args) => { Debug.Log(\"Run My Command2\"); }); contextMenu.Open(new[] { cmd1, cmd2 }); } } Built-in context menu populated and opened from Assets/Battlehub/RTEditor/Scripts/ ProjectFolderView.cs and ProjectTreeView.cs RTEDeps The main purpose of the Assets/Battlehub/RTEditor/ RTEDeps.cs class is to register various services into IOC : IResourcePreviewUtility - create preview for Game Object or asset. IWindowManager - manage build-in and custom windows. IContextMenu - create and show context menu. IRuntimeConsole - log messages cache. IRuntimeEditor - the main interface of the RuntimeEditor. IRuntimeEditor IRuntimeEditor inherits the IRTE interface and adds several important methods and events. using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetRuntimeEditor : MonoBehaviour { void Start() { IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); } } Events: event RTEEvent SceneLoading - fired before loading the scene. event RTEEvent SceneLoaded - fired after loading the scene. event RTEEvent SceneSaving - fired before saving the scene. event RTEEvent SceneSaved - fired before saving the scene. Methods: void NewScene(bool confirm = true) - create a new scene (show the confirmation dialog by default). void SaveScene() - save the current scene. If the scene is new, the save scene dialog will appear. void CreateWindow(string window) - call corresponding method of window manager . void CreateOrActivateWindow(string window) - this method creates a window only if it does not exist. ProjectAsyncOperation<AssetItem[]> CreatePrefab(ProjectItem folder, ExposeToEditor obj, bool? includeDeps = null) - create prefab with preview. ProjectAsyncOperation<AssetItem> SaveAsset(UnityObject obj) - save asset. ProjectAsyncOperation<ProjectItem[]> DeleteAssets(ProjectItem[] projectItems) - delete assets. ProjectAsyncOperation<AssetItem> UpdatePreview(UnityObject obj) - update asset preview. Example: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.RTSL.Interface; using System.Collections; using UnityEngine; public class IRuntimeEditorMethodsUsageExample : MonoBehaviour { IEnumerator Start() { //Get runtime editor IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); //Use IProject interface if editor is not opened or does not exist. //See save-load/#project for details Debug.Assert(editor.IsOpened); //Create Prefabs folder IProject project = IOC.Resolve<IProject>(); yield return project.CreateFolder(\"Prefabs\"); ProjectItem folder = project.GetFolder(\"Prefabs\"); //Create new object and hide it from hierarchy GameObject go = GameObject.CreatePrimitive(PrimitiveType.Sphere); go.hideFlags = HideFlags.HideAndDontSave; go.SetActive(false); //Create prefab with preview and destroy source object yield return editor.CreatePrefab(folder, go.AddComponent<ExposeToEditor>(), true); Destroy(go); //Load prefab ProjectAsyncOperation<Object[]> load = project.Load<GameObject>(\"Prefabs/Sphere\"); yield return load; GameObject loadedGO = load.Result[0] as GameObject; //... Make changes //Update preview yield return editor.UpdatePreview(loadedGO); //Save changes yield return editor.SaveAsset(loadedGO); //Get corresponding project item ProjectItem projectItem = project.Get<GameObject>(\"Prefabs/Sphere\"); //Delete prefab and clear undo stack yield return editor.DeleteAssets(new[] { projectItem }); } } Window Manager Window Manager allows you to create complex windows, such as an inspector or scene, and simple dialogs, such as a message box or confirmation. The difference between dialog and window is rather subtle. The content of the dialog can be anything, and it can not be docked. To be considered as a window or dialog window, a Runtime Window component must be attached to the game object. When the runtime window is activated, the other windows are deactivated. The dialog cannot deactivate the window. Note Default windows and dialogs can be found in Assets/Battlehub/RTEditor/ Prefabs Note Window Manager use dock panels control. Get window manager: using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetWindowManager : MonoBehaviour { void Start() { IWindowManager wm = IOC.Resolve<IWindowManager>(); } } Show message box: wm.MessageBox(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"OK Click\"); }); Show confirmation: wm.Confirmation(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"Yes click\"); }, (sender, args) => { Debug.Log(\"No click\"); }, \"Yes\", \"No\"); Activate window: wm.ActivateWindow(RuntimeWindowType.Scene.ToString()); Create window: wm.CreateWindow(RuntimeWindowType.Scene.ToString()); Create dialog window: IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.CreateDialogWindow(RuntimeWindowType.Scene.ToString(), \"Header\", (sender, args) => { Debug.Log(\"OK\"); }, (sender, args) => { Debug.Log(\"Cancel\"); }); Set default layout: IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.SetDefaultLayout(); How to: add custom window to Window Manager Note For information on how to create custom window please navigate to this -> this <- section Create class derived from Runtime Window Duplicate Assets/Battlehub/RTEditor/Prefabs/Views/Resources/ TemplateWindow.prefab . Add CustomWindow component created in step 1. Set Window Type to Custom . Create Initialization script and add it to game object in the scene. using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; [MenuDefinition] public class Initialization : MonoBehaviour { private IRuntimeEditor m_editor; void Start() { m_editor = IOC.Resolve<IRuntimeEditor>(); m_editor.IsOpenedChanged += RegisterWindows; RegisterWindows(); } void OnDestroy() { if(m_editor != null) { m_editor.IsOpenedChanged -= RegisterWindows; } } private void RegisterWindows() { if (!m_editor.IsOpened) { return; } IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.RegisterWindow(new CustomWindowDescriptor { IsDialog = false, TypeName = \"MyWindow\", Descriptor = new WindowDescriptor { Header = \"My Window\", MaxWindows = 1, Icon = Resources.Load<Sprite>(\"IconNew\"), ContentPrefab = Resources.Load<GameObject>(\"CustomWindow\") } }); } [MenuCommand(\"MenuWindow/CustomWindow\")] public static void ShowCustomWindow() { IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.CreateWindow(\"MyWindow\"); } } Inspector View The main purpose of the inspector is to create different editors depending on the type of selected object and its components. Here is a general idea of what is happening: The user selects a Game Object, and the inspector creates a GameObject editor. The game object editor creates component editors. Each component editor creates property editors. Prefabs: InspectorView can be found in Assets/Battlehub/RTEditor/Prefabs folder, GameObject , Material and Component editors in Assets/Battlehub/RTEditor/Prefabs/Editors, Property editors in Assets/Battlehub/RTEditor/Prefabs/Editors/PropertyEditors. How To: Configure Editors To select the editors to be used by the inspector, click Tools->Runtime Editor->Configuration There are five sections in configuration window: Object Editors - select which editor to use for Game Object. Property Editors - select which editors to use for component properties. Material Editors - select which editors to use for materials Standard Component Editors \u2013 select which editors to use for standard components. Script Editors \u2013 select which editors to use for scripts. After you select and enable the desired component editors, click the Save Editors Map button How To: Select Component Properties In order to select the properties displayed by the component editor, you need to create a class and inherit it from ComponentDescriptorBase< > . After that, you need to implement the GetProperties method. It must return PropertyDescriptors for all properties that will be present in the component editor ui. Here is the example of TransformComponentDescriptor : using UnityEngine; using System.Reflection; using Battlehub.Utils; namespace Battlehub.RTEditor { public class TransformComponentDescriptor : ComponentDescriptorBase<Transform> { public override object CreateConverter(ComponentEditor editor) { TransformPropertyConverter converter = new TransformPropertyConverter(); converter.Component = (Transform)editor.Component; return converter; } public override PropertyDescriptor[] GetProperties(ComponentEditor editor, object converterObj) { TransformPropertyConverter converter = (TransformPropertyConverter)converterObj; MemberInfo position = Strong.PropertyInfo((Transform x) => x.position); MemberInfo rotation = Strong.PropertyInfo((Transform x) => x.rotation); MemberInfo rotationConverted = Strong.PropertyInfo((TransformPropertyConverter x) => x.Rotation); MemberInfo scale = Strong.PropertyInfo((Transform x) => x.localScale); return new[] { new PropertyDescriptor( \"Position\", editor.Component, position) , new PropertyDescriptor( \"Rotation\", converter, rotationConverted, rotation), new PropertyDescriptor( \"Scale\", editor.Component, scale) }; } } public class TransformPropertyConverter { public Vector3 Rotation { get { if(Component == null) { return Vector3.zero; } return Component.rotation.eulerAngles; } set { if (Component == null) { return; } Component.rotation = Quaternion.Euler(value); } } public Transform Component { get; set; } } } TransformPropertyConverter is used to convert a quaternion to Euler angles. This is needed for Vector3Editor to be used instead of QuaternionEditor. Note The remaining built-in component descriptors are in the Assets/Battlehub/RTEditor/Scripts/Editors/ComponentDescriptors folder. Resource Preview Utility The resource preview utility is used to create previews for objects. Here is how to used it: using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class CreatePreviewExample : MonoBehaviour { [SerializeField] Image m_image = null; Texture2D m_previewTexture; void Start() { m_previewTexture = new Texture2D(1, 1, TextureFormat.ARGB32, true); IResourcePreviewUtility resourcePreviewUtility = IOC.Resolve<IResourcePreviewUtility>(); byte[] previewData = resourcePreviewUtility.CreatePreviewData(gameObject); m_previewTexture.LoadImage(assetItem.Preview.PreviewData); m_image.sprite = Sprite.Create(m_previewTexture, new Rect(0, 0, m_previewTexture.width, m_previewTexture.height), new Vector2(0.5f, 0.5f)); } void OnDestroy() { if (m_previewTexture != null) { Destroy(m_previewTexture); } } }","title":"Runtime Editor"},{"location":"runtime-editor/#runtime-editor-docs","text":"","title":"Runtime Editor Docs"},{"location":"runtime-editor/#overview","text":"Runtime Editor is the set of scripts and prefabs which help you to create scene editor, game level editor or build your own modeling application. It supports drag & drop , undo & redo and selection api. To implement user interface and core functions runtime editor use transform-handles , gizmos , save load subsystem and three controls: menu , virtualizing tree view and dock panels . Out of the box it has six Views: Scene View to manipulate objects in the scene. Hierarchy View for displaying and manipulating the object tree. Project View to manage assets and scenes. Inspector View to display and edit object properties. Console View to display information, warnings and errors. Game View for the game. Add More... The Runtime Editor has many ready-to-use property and component editors and it is relatively easy to create new ones . \"Add Component\" drop-down button allows you to add components at runtime. There are also several important dialogs included: Save Scene Dialog . Object Picker . Color Picker . Asset Bundles and Libraries Importer . Manage Projects Dialog .","title":"Overview"},{"location":"runtime-editor/#getting-started","text":"To get started with Runtime Editor do following: Create new scene and save it. Click Tools->Runtime Editor->Create Add Battlehub/RTEditor/Scripts/ Game View Camera component to Main Camera Create several Game Objects and add Expose To Editor component. Click Tools->Runtime SaveLoad->Build All Hit Play Few more steps: Create Asset Library Launch runtime editor and click File->Import Assets . Select the built-in asset library created in step 1. Import assets. You will see the imported assets in the project window. Note Demo scene can be found in Assets/Battlehub/RTEditor/Demo","title":"Getting Started"},{"location":"runtime-editor/#main-context-menu","text":"Runtime Editor use Menu control to implement main and context-menu. To extend main menu create static class with [MenuDefinition] attribute and add static methods with [MenuCommand] attribute. using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; [MenuDefinition] public static class MyMenu { /// add new command to exising menu [MenuCommand(\"MenuWindow/Create My Window\")] public static void CreateMyWindow() { Debug.Log(\"Create My Window\"); } /// add new command to new menu [MenuCommand(\"My Menu/My Submenu/My Command\")] public static void CreateMyMenu() { Debug.Log(\"Create My Menu\"); } /// disable menu item [MenuCommand(\"My Menu/My Submenu/My Command\", validate: true)] public static bool ValidateMyCommand() { Debug.Log(\"Disable My Command\"); return false; } /// replace existing menu item [MenuCommand(\"MenuFile/Close\")] public static void Close() { Debug.Log(\"Intercepted\"); IRuntimeEditor rte = IOC.Resolve<IRuntimeEditor>(); rte.Close(); } /// Hide existing menu item [MenuCommand(\"MenuHelp/About RTE\", hide: true)] public static void HideAbout() { } } To open context menu with custom commands do following: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; public static class MyContextMenu { public static void OpenContextMenu() { IContextMenu contextMenu = IOC.Resolve<IContextMenu>(); MenuItemInfo cmd1 = new MenuItemInfo { Path = \"My Command 1\" }; cmd1.Action = new MenuItemEvent(); cmd1.Action.AddListener((args) => { Debug.Log(\"Run My Command1\"); IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); Debug.Log(editor.Selection.activeGameObject); }); MenuItemInfo cmd2 = new MenuItemInfo { Path = \"My Command 2\" }; cmd2.Validate = new MenuItemValidationEvent(); cmd2.Action = new MenuItemEvent(); cmd2.Validate.AddListener((args) => { args.IsValid = false; }); cmd2.Action.AddListener((args) => { Debug.Log(\"Run My Command2\"); }); contextMenu.Open(new[] { cmd1, cmd2 }); } } Built-in context menu populated and opened from Assets/Battlehub/RTEditor/Scripts/ ProjectFolderView.cs and ProjectTreeView.cs","title":"Main &amp; Context Menu"},{"location":"runtime-editor/#rtedeps","text":"The main purpose of the Assets/Battlehub/RTEditor/ RTEDeps.cs class is to register various services into IOC : IResourcePreviewUtility - create preview for Game Object or asset. IWindowManager - manage build-in and custom windows. IContextMenu - create and show context menu. IRuntimeConsole - log messages cache. IRuntimeEditor - the main interface of the RuntimeEditor.","title":"RTEDeps"},{"location":"runtime-editor/#iruntimeeditor","text":"IRuntimeEditor inherits the IRTE interface and adds several important methods and events. using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetRuntimeEditor : MonoBehaviour { void Start() { IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); } } Events: event RTEEvent SceneLoading - fired before loading the scene. event RTEEvent SceneLoaded - fired after loading the scene. event RTEEvent SceneSaving - fired before saving the scene. event RTEEvent SceneSaved - fired before saving the scene. Methods: void NewScene(bool confirm = true) - create a new scene (show the confirmation dialog by default). void SaveScene() - save the current scene. If the scene is new, the save scene dialog will appear. void CreateWindow(string window) - call corresponding method of window manager . void CreateOrActivateWindow(string window) - this method creates a window only if it does not exist. ProjectAsyncOperation<AssetItem[]> CreatePrefab(ProjectItem folder, ExposeToEditor obj, bool? includeDeps = null) - create prefab with preview. ProjectAsyncOperation<AssetItem> SaveAsset(UnityObject obj) - save asset. ProjectAsyncOperation<ProjectItem[]> DeleteAssets(ProjectItem[] projectItems) - delete assets. ProjectAsyncOperation<AssetItem> UpdatePreview(UnityObject obj) - update asset preview. Example: using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.RTSL.Interface; using System.Collections; using UnityEngine; public class IRuntimeEditorMethodsUsageExample : MonoBehaviour { IEnumerator Start() { //Get runtime editor IRuntimeEditor editor = IOC.Resolve<IRuntimeEditor>(); //Use IProject interface if editor is not opened or does not exist. //See save-load/#project for details Debug.Assert(editor.IsOpened); //Create Prefabs folder IProject project = IOC.Resolve<IProject>(); yield return project.CreateFolder(\"Prefabs\"); ProjectItem folder = project.GetFolder(\"Prefabs\"); //Create new object and hide it from hierarchy GameObject go = GameObject.CreatePrimitive(PrimitiveType.Sphere); go.hideFlags = HideFlags.HideAndDontSave; go.SetActive(false); //Create prefab with preview and destroy source object yield return editor.CreatePrefab(folder, go.AddComponent<ExposeToEditor>(), true); Destroy(go); //Load prefab ProjectAsyncOperation<Object[]> load = project.Load<GameObject>(\"Prefabs/Sphere\"); yield return load; GameObject loadedGO = load.Result[0] as GameObject; //... Make changes //Update preview yield return editor.UpdatePreview(loadedGO); //Save changes yield return editor.SaveAsset(loadedGO); //Get corresponding project item ProjectItem projectItem = project.Get<GameObject>(\"Prefabs/Sphere\"); //Delete prefab and clear undo stack yield return editor.DeleteAssets(new[] { projectItem }); } }","title":"IRuntimeEditor"},{"location":"runtime-editor/#window-manager","text":"Window Manager allows you to create complex windows, such as an inspector or scene, and simple dialogs, such as a message box or confirmation. The difference between dialog and window is rather subtle. The content of the dialog can be anything, and it can not be docked. To be considered as a window or dialog window, a Runtime Window component must be attached to the game object. When the runtime window is activated, the other windows are deactivated. The dialog cannot deactivate the window. Note Default windows and dialogs can be found in Assets/Battlehub/RTEditor/ Prefabs Note Window Manager use dock panels control. Get window manager: using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class GetWindowManager : MonoBehaviour { void Start() { IWindowManager wm = IOC.Resolve<IWindowManager>(); } } Show message box: wm.MessageBox(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"OK Click\"); }); Show confirmation: wm.Confirmation(\"Header\", \"Text\", (sender, args) => { Debug.Log(\"Yes click\"); }, (sender, args) => { Debug.Log(\"No click\"); }, \"Yes\", \"No\"); Activate window: wm.ActivateWindow(RuntimeWindowType.Scene.ToString()); Create window: wm.CreateWindow(RuntimeWindowType.Scene.ToString()); Create dialog window: IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.CreateDialogWindow(RuntimeWindowType.Scene.ToString(), \"Header\", (sender, args) => { Debug.Log(\"OK\"); }, (sender, args) => { Debug.Log(\"Cancel\"); }); Set default layout: IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.SetDefaultLayout();","title":"Window Manager"},{"location":"runtime-editor/#how-to-add-custom-window-to-window-manager","text":"Note For information on how to create custom window please navigate to this -> this <- section Create class derived from Runtime Window Duplicate Assets/Battlehub/RTEditor/Prefabs/Views/Resources/ TemplateWindow.prefab . Add CustomWindow component created in step 1. Set Window Type to Custom . Create Initialization script and add it to game object in the scene. using Battlehub.RTCommon; using Battlehub.RTEditor; using Battlehub.UIControls.MenuControl; using UnityEngine; [MenuDefinition] public class Initialization : MonoBehaviour { private IRuntimeEditor m_editor; void Start() { m_editor = IOC.Resolve<IRuntimeEditor>(); m_editor.IsOpenedChanged += RegisterWindows; RegisterWindows(); } void OnDestroy() { if(m_editor != null) { m_editor.IsOpenedChanged -= RegisterWindows; } } private void RegisterWindows() { if (!m_editor.IsOpened) { return; } IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.RegisterWindow(new CustomWindowDescriptor { IsDialog = false, TypeName = \"MyWindow\", Descriptor = new WindowDescriptor { Header = \"My Window\", MaxWindows = 1, Icon = Resources.Load<Sprite>(\"IconNew\"), ContentPrefab = Resources.Load<GameObject>(\"CustomWindow\") } }); } [MenuCommand(\"MenuWindow/CustomWindow\")] public static void ShowCustomWindow() { IWindowManager wm = IOC.Resolve<IWindowManager>(); wm.CreateWindow(\"MyWindow\"); } }","title":"How to: add custom window to Window Manager"},{"location":"runtime-editor/#inspector-view","text":"The main purpose of the inspector is to create different editors depending on the type of selected object and its components. Here is a general idea of what is happening: The user selects a Game Object, and the inspector creates a GameObject editor. The game object editor creates component editors. Each component editor creates property editors. Prefabs: InspectorView can be found in Assets/Battlehub/RTEditor/Prefabs folder, GameObject , Material and Component editors in Assets/Battlehub/RTEditor/Prefabs/Editors, Property editors in Assets/Battlehub/RTEditor/Prefabs/Editors/PropertyEditors.","title":"Inspector View"},{"location":"runtime-editor/#how-to-configure-editors","text":"To select the editors to be used by the inspector, click Tools->Runtime Editor->Configuration There are five sections in configuration window: Object Editors - select which editor to use for Game Object. Property Editors - select which editors to use for component properties. Material Editors - select which editors to use for materials Standard Component Editors \u2013 select which editors to use for standard components. Script Editors \u2013 select which editors to use for scripts. After you select and enable the desired component editors, click the Save Editors Map button","title":"How To: Configure Editors"},{"location":"runtime-editor/#how-to-select-component-properties","text":"In order to select the properties displayed by the component editor, you need to create a class and inherit it from ComponentDescriptorBase< > . After that, you need to implement the GetProperties method. It must return PropertyDescriptors for all properties that will be present in the component editor ui. Here is the example of TransformComponentDescriptor : using UnityEngine; using System.Reflection; using Battlehub.Utils; namespace Battlehub.RTEditor { public class TransformComponentDescriptor : ComponentDescriptorBase<Transform> { public override object CreateConverter(ComponentEditor editor) { TransformPropertyConverter converter = new TransformPropertyConverter(); converter.Component = (Transform)editor.Component; return converter; } public override PropertyDescriptor[] GetProperties(ComponentEditor editor, object converterObj) { TransformPropertyConverter converter = (TransformPropertyConverter)converterObj; MemberInfo position = Strong.PropertyInfo((Transform x) => x.position); MemberInfo rotation = Strong.PropertyInfo((Transform x) => x.rotation); MemberInfo rotationConverted = Strong.PropertyInfo((TransformPropertyConverter x) => x.Rotation); MemberInfo scale = Strong.PropertyInfo((Transform x) => x.localScale); return new[] { new PropertyDescriptor( \"Position\", editor.Component, position) , new PropertyDescriptor( \"Rotation\", converter, rotationConverted, rotation), new PropertyDescriptor( \"Scale\", editor.Component, scale) }; } } public class TransformPropertyConverter { public Vector3 Rotation { get { if(Component == null) { return Vector3.zero; } return Component.rotation.eulerAngles; } set { if (Component == null) { return; } Component.rotation = Quaternion.Euler(value); } } public Transform Component { get; set; } } } TransformPropertyConverter is used to convert a quaternion to Euler angles. This is needed for Vector3Editor to be used instead of QuaternionEditor. Note The remaining built-in component descriptors are in the Assets/Battlehub/RTEditor/Scripts/Editors/ComponentDescriptors folder.","title":"How To: Select Component Properties"},{"location":"runtime-editor/#resource-preview-utility","text":"The resource preview utility is used to create previews for objects. Here is how to used it: using Battlehub.RTCommon; using Battlehub.RTEditor; using UnityEngine; public class CreatePreviewExample : MonoBehaviour { [SerializeField] Image m_image = null; Texture2D m_previewTexture; void Start() { m_previewTexture = new Texture2D(1, 1, TextureFormat.ARGB32, true); IResourcePreviewUtility resourcePreviewUtility = IOC.Resolve<IResourcePreviewUtility>(); byte[] previewData = resourcePreviewUtility.CreatePreviewData(gameObject); m_previewTexture.LoadImage(assetItem.Preview.PreviewData); m_image.sprite = Sprite.Create(m_previewTexture, new Rect(0, 0, m_previewTexture.width, m_previewTexture.height), new Vector2(0.5f, 0.5f)); } void OnDestroy() { if (m_previewTexture != null) { Destroy(m_previewTexture); } } }","title":"Resource Preview Utility"},{"location":"save-load/","text":"Save Load Docs Overview The Runtime Save & Load (RTSL) subsystem is required for saving and managing scenes, assets and projects at runtime and consists of three main parts: Persistent Classes - this part allows you to choose what to serialize and generate persistent classes for serialization. Asset Libraries - this part allows you to create and manage assets, as well as provide information to the RTSL to identify these assets. Project - this part provides api to interact with RTSL. Note RTSL use protobuf.net for serialization. Getting Started After importing RTSL you will see the configuration window: After clicking \"Build All\", several folders will be created under /Battlehub/RTSL_Data Scripts for serializable persistent classes . Custom Implementation for user defined persistent classes. Mappings for mappings between types that must be stored and serializable persistent types. Libraries for asset libraries and shader profiles . Note RTSLTypeModel.dll contains protobuf-net type model. Due to unity scripting restrictions , runtime type model need to be pre-complied before using at runtime. Create new scene Drag and Drop Assets/Battlehub/RTDemoGame/Prefabs/Game.prefab to hierarchy. Click Tools->Runtime SaveLoad->Libraries-> Collect Scene Dependencies Create Game Object, then add Assets/Battlehub/RTSL/Interface/ Project and Assets/Battlehub/RTSL/Interface/ RTSLIgnore components. Create RTSLTest script. Hit play. Save scene using 'M' key. Load scene using 'L' key. using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; public class RTSLTest : MonoBehaviour { IProject m_project; IEnumerator Start() { m_project = IOC.Resolve<IProject>(); yield return m_project.OpenProject(\"My Project\"); yield return m_project.CreateFolder(\"Scenes/Demo\"); } IEnumerator SaveScene() { ProjectAsyncOperation ao = m_project.Save(\"Scenes/Demo/Scene\", SceneManager.GetActiveScene()); yield return ao; if(ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } IEnumerator LoadScene() { ProjectAsyncOperation ao = m_project.Load<Scene>(\"Scenes/Demo/Scene\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } void Update() { if (Input.GetKeyDown(KeyCode.M)) { StartCoroutine(SaveScene()); } if (Input.GetKeyDown(KeyCode.L)) { if (m_project.Exist<Scene>(\"Scenes/Demo/Scene\")) { StartCoroutine(LoadScene()); } } } } Saved scene can be found in PersistentDataPath /My Project/Assets/Scenes/Demo folder . Note Only few persistent classes enabled and could be saved by default. Use Persistent Classes Editor Window to enable more. Note Demo scene can be found in Assets/Battlehub/RTSL/Demo folder. Persistent Classes Persistent Class is a class derived from Persistent Surrogate and having the [ProtoContract] attribute. The main purpose of the persistent classes is to give you full control over what and how to save, without having to use reflection and without writing a lot of code. To open persistent classes editor, click Tools->Runtime SaveLoad-> Persistent Classes->Edit . Here is the persistent classes editor window: This window allow you: Search for types you want to save. Select properties you want to save. Generate C# code of persistent classes. After clicking the \"Create Persistent Classes\" button the following will occur: Persistent classes will be created in Assets/Battlehub/RTSL_Data/Scripts/PersistentClasses . The editor window state will be saved in Assets/Battlehub/RTSL_Data/Mappings/Editor . Custom Implementation will be created in .../RTSL_Data/Scripts/CustomImplementation . Note To ensure forward compatibility of saved files, never delete the ClassMappingStorage and SurrogatesMappingsStorage prefabs !!! How To: Create Custom Persistent Class In some cases, it is not possible to get all the data to be saved using public properties and fields. For example, data can only be obtained using the methods. If you have to write your own code to save and load data, follow these steps: Open Persistent Classes Editor. Find and select required type. Select \"Custom Implementation\" Click Create Persistent Classes button. Click Edit Custom Implementation button. You should see following: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint { /* public override void ReadFrom(object obj) { base.ReadFrom(obj); } public override object WriteTo(object obj) { return base.WriteTo(obj); } public override void GetDeps(GetDepsContext context) { base.GetDeps(context); } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); } */ } } #endif There are four methods that can be implemented: void ReadFrom(object obj) - invoked before serialization. Read the data from obj and save it to the fields of the persistent object. object WriteTo(object obj) - invoked after deserialization. Write stored data to obj. void GetDeps(GetDepsContext context) - return identifiers of dependencies. void GetDepsFrom(object obj, GetDepsFromContext context) - get dependencies from obj. Implementation of PersistentJoint may look like this: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint { [ProtoBuf.ProtoMember(1)] private long m_connectedBody; [ProtoBuf.ProtoMember(2)] private PersistentVector3 m_anchor; //..... more fields public override void ReadFrom(object obj) { base.ReadFrom(obj); Joint joint = (Joint)obj; if(joint == null) { return; } m_connectedBody = ToID(joint.connectedBody); m_anchor = joint.anchor; //... read other fields } public override object WriteTo(object obj) { obj = base.WriteTo(obj); Joint joint = (Joint)obj; if (joint == null) { return obj; } joint.connectedBody = FromID<Rigidbody>(m_connectedBody); joint.anchor = m_anchor; //... write other fields return joint; } public override void GetDeps(GetDepsContext context) { base.GetDeps(context); AddDep(m_connectedBody, context); //... get other dependencies } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); Joint joint = (Joint)obj; if (joint == null) { return; } AddDep(joint.connectedBody, context); //... get other dependencies } } } #endif Note Click Tools-> Runtime SaveLoad-> Build All each time you have finished making changes to persistent classes and are ready to build the application. Asset Library Game objects in any scene refer assets such as materials, meshes, textures, etc. Identifiers of these assets obtained using GetInstanceID() method do not remain constant and can change. In contrast, Asset libraries are used to store unique asset identifiers that never change. There are two special asset libraries: Built-in asset library - contains Unity build-in assets. Scene asset library - contains assets referenced by scene Game Objects. The former library created automatically by clicking Tools->Runtime SaveLoad->Libraries->Update Built-In Asset Library The latter created by opening scene and clicking Tools->Runtime SaveLoad->Libraries->Collect Scene Dependencies Note Scene asset libraries are referenced using the scene name. This means that scenes must have unique names. Note Click Tools->Runtime SaveLoad->Libraries->Collect Scene Dependencies each time you have finished making changes to scene and are ready to run the application. How To: Create Asset Library If the built-in asset library and scene dependency library are not sufficient, and the new resources must be Resource.Loaded at runtime, you can create a new asset library by clicking Create-> Runtime Asset Library in the context menu. Note An asset library must be created inside the Resources folder. Use drag & drop to add assets to asset library Note One asset library can contain no more than 65535 assets. If you change one or more prefabs, you will be asked to synchronize the assets library. Do it by clicking Synchronize button. Project Item & Asset Item Project Items are used to create tree structures representing the project tree. [ProtoContract] [ProtoInclude(1, typeof(AssetItem))] public class ProjectItem { [ProtoMember(2)] public long ItemID; public string Name; public string Ext; public ProjectItem Parent; public List<ProjectItem> Children; // ... Asset Items are meta representations of assets in a project. They are stored in *.rtmeta files. [ProtoContract] public class AssetItem : ProjectItem { public event EventHandler PreviewDataChanged; [ProtoMember(1)] public Guid TypeGuid; [ProtoMember(2)] public PrefabPart[] Parts; [ProtoMember(3)] public long[] Dependencies; private Preview m_preview; public Preview Preview { get { return m_preview; } set { if (m_preview != value) { m_preview = value; if (PreviewDataChanged != null) { PreviewDataChanged(this, EventArgs.Empty); } } } } public override bool IsFolder { get { return false; } } } Project IProject is the main interface of the RTSL library. Here is how to access it: using Battlehub.RTCommon; using Battlehub.RTSL.Interface; void Awake() { IProject project = IOC.Resolve<IProject>(); } Open project: using System.Collections; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { IProject project = IOC.Resolve<IProject>(); yield return project.OpenProject(\"My Project\"); } Close project: m_project.CloseProject(); Delete project: yield return project.DeleteProject(\"My Project\"); Create folder: yield return project.CreateFolder(\"My Scenes\"); Delete folder: yield return project.DeleteFolder(\"My Scenes\"); Save scene: using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Save(\"My Scenes/Scene 1\", SceneManager.GetActiveScene()); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } Load scene: using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Load<Scene>(\"My Scenes/Scene 1\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } Delete scene: yield return project.Delete<Scene>(\"My Scenes/Scene 1\"); Find objects of type: foreach(string scene in project.Find<Scene>(\"Scene 1\")) { Debug.Log(scene); } Create Prefab: GameObject primitive = GameObject.CreatePrimitive(PrimitiveType.Capsule); yield return project.Save(\"Capsule\", primitive); Destroy(primitive); Load and instantiate Prefab: ProjectAsyncOperation<Object[]> ao = project.Load<GameObject>(\"Capsule\"); yield return ao; if(!ao.Error.HasError) { Instantiate(ao.Result[0]); } Import all assets from asset bundle: //get names of asset bundles from Assets/StreamingAssets folder. ProjectAsyncOperation<string[]> ao = project.GetAssetBundles(); yield return ao; //load ImportItems from first asset bundle ProjectAsyncOperation<ProjectItem> loadAo = project.LoadImportItems(ao.Result[0], false); yield return loadAo; if (!loadAo.Error.HasError) { //create previews here... //then unload asset bundle assets project.UnloadImportItems(loadAo.Result); //import all yield return project.Import(loadAo.Result.Flatten(true).OfType<ImportItem>().ToArray()); } //log all asset items in project foreach(string path in project.Find<object>(string.Empty, true)) { Debug.Log(path); }","title":"Save Load"},{"location":"save-load/#save-load-docs","text":"","title":"Save Load Docs"},{"location":"save-load/#overview","text":"The Runtime Save & Load (RTSL) subsystem is required for saving and managing scenes, assets and projects at runtime and consists of three main parts: Persistent Classes - this part allows you to choose what to serialize and generate persistent classes for serialization. Asset Libraries - this part allows you to create and manage assets, as well as provide information to the RTSL to identify these assets. Project - this part provides api to interact with RTSL. Note RTSL use protobuf.net for serialization.","title":"Overview"},{"location":"save-load/#getting-started","text":"After importing RTSL you will see the configuration window: After clicking \"Build All\", several folders will be created under /Battlehub/RTSL_Data Scripts for serializable persistent classes . Custom Implementation for user defined persistent classes. Mappings for mappings between types that must be stored and serializable persistent types. Libraries for asset libraries and shader profiles . Note RTSLTypeModel.dll contains protobuf-net type model. Due to unity scripting restrictions , runtime type model need to be pre-complied before using at runtime. Create new scene Drag and Drop Assets/Battlehub/RTDemoGame/Prefabs/Game.prefab to hierarchy. Click Tools->Runtime SaveLoad->Libraries-> Collect Scene Dependencies Create Game Object, then add Assets/Battlehub/RTSL/Interface/ Project and Assets/Battlehub/RTSL/Interface/ RTSLIgnore components. Create RTSLTest script. Hit play. Save scene using 'M' key. Load scene using 'L' key. using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; public class RTSLTest : MonoBehaviour { IProject m_project; IEnumerator Start() { m_project = IOC.Resolve<IProject>(); yield return m_project.OpenProject(\"My Project\"); yield return m_project.CreateFolder(\"Scenes/Demo\"); } IEnumerator SaveScene() { ProjectAsyncOperation ao = m_project.Save(\"Scenes/Demo/Scene\", SceneManager.GetActiveScene()); yield return ao; if(ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } IEnumerator LoadScene() { ProjectAsyncOperation ao = m_project.Load<Scene>(\"Scenes/Demo/Scene\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } void Update() { if (Input.GetKeyDown(KeyCode.M)) { StartCoroutine(SaveScene()); } if (Input.GetKeyDown(KeyCode.L)) { if (m_project.Exist<Scene>(\"Scenes/Demo/Scene\")) { StartCoroutine(LoadScene()); } } } } Saved scene can be found in PersistentDataPath /My Project/Assets/Scenes/Demo folder . Note Only few persistent classes enabled and could be saved by default. Use Persistent Classes Editor Window to enable more. Note Demo scene can be found in Assets/Battlehub/RTSL/Demo folder.","title":"Getting Started"},{"location":"save-load/#persistent-classes","text":"Persistent Class is a class derived from Persistent Surrogate and having the [ProtoContract] attribute. The main purpose of the persistent classes is to give you full control over what and how to save, without having to use reflection and without writing a lot of code. To open persistent classes editor, click Tools->Runtime SaveLoad-> Persistent Classes->Edit . Here is the persistent classes editor window: This window allow you: Search for types you want to save. Select properties you want to save. Generate C# code of persistent classes. After clicking the \"Create Persistent Classes\" button the following will occur: Persistent classes will be created in Assets/Battlehub/RTSL_Data/Scripts/PersistentClasses . The editor window state will be saved in Assets/Battlehub/RTSL_Data/Mappings/Editor . Custom Implementation will be created in .../RTSL_Data/Scripts/CustomImplementation . Note To ensure forward compatibility of saved files, never delete the ClassMappingStorage and SurrogatesMappingsStorage prefabs !!!","title":"Persistent Classes"},{"location":"save-load/#how-to-create-custom-persistent-class","text":"In some cases, it is not possible to get all the data to be saved using public properties and fields. For example, data can only be obtained using the methods. If you have to write your own code to save and load data, follow these steps: Open Persistent Classes Editor. Find and select required type. Select \"Custom Implementation\" Click Create Persistent Classes button. Click Edit Custom Implementation button. You should see following: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint { /* public override void ReadFrom(object obj) { base.ReadFrom(obj); } public override object WriteTo(object obj) { return base.WriteTo(obj); } public override void GetDeps(GetDepsContext context) { base.GetDeps(context); } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); } */ } } #endif There are four methods that can be implemented: void ReadFrom(object obj) - invoked before serialization. Read the data from obj and save it to the fields of the persistent object. object WriteTo(object obj) - invoked after deserialization. Write stored data to obj. void GetDeps(GetDepsContext context) - return identifiers of dependencies. void GetDepsFrom(object obj, GetDepsFromContext context) - get dependencies from obj. Implementation of PersistentJoint may look like this: #if !RTSL_MAINTENANCE using Battlehub.RTSL; namespace UnityEngine.Battlehub.SL2 { [CustomImplementation] public partial class PersistentJoint { [ProtoBuf.ProtoMember(1)] private long m_connectedBody; [ProtoBuf.ProtoMember(2)] private PersistentVector3 m_anchor; //..... more fields public override void ReadFrom(object obj) { base.ReadFrom(obj); Joint joint = (Joint)obj; if(joint == null) { return; } m_connectedBody = ToID(joint.connectedBody); m_anchor = joint.anchor; //... read other fields } public override object WriteTo(object obj) { obj = base.WriteTo(obj); Joint joint = (Joint)obj; if (joint == null) { return obj; } joint.connectedBody = FromID<Rigidbody>(m_connectedBody); joint.anchor = m_anchor; //... write other fields return joint; } public override void GetDeps(GetDepsContext context) { base.GetDeps(context); AddDep(m_connectedBody, context); //... get other dependencies } public override void GetDepsFrom(object obj, GetDepsFromContext context) { base.GetDepsFrom(obj, context); Joint joint = (Joint)obj; if (joint == null) { return; } AddDep(joint.connectedBody, context); //... get other dependencies } } } #endif Note Click Tools-> Runtime SaveLoad-> Build All each time you have finished making changes to persistent classes and are ready to build the application.","title":"How To: Create Custom Persistent Class"},{"location":"save-load/#asset-library","text":"Game objects in any scene refer assets such as materials, meshes, textures, etc. Identifiers of these assets obtained using GetInstanceID() method do not remain constant and can change. In contrast, Asset libraries are used to store unique asset identifiers that never change. There are two special asset libraries: Built-in asset library - contains Unity build-in assets. Scene asset library - contains assets referenced by scene Game Objects. The former library created automatically by clicking Tools->Runtime SaveLoad->Libraries->Update Built-In Asset Library The latter created by opening scene and clicking Tools->Runtime SaveLoad->Libraries->Collect Scene Dependencies Note Scene asset libraries are referenced using the scene name. This means that scenes must have unique names. Note Click Tools->Runtime SaveLoad->Libraries->Collect Scene Dependencies each time you have finished making changes to scene and are ready to run the application.","title":"Asset Library"},{"location":"save-load/#how-to-create-asset-library","text":"If the built-in asset library and scene dependency library are not sufficient, and the new resources must be Resource.Loaded at runtime, you can create a new asset library by clicking Create-> Runtime Asset Library in the context menu. Note An asset library must be created inside the Resources folder. Use drag & drop to add assets to asset library Note One asset library can contain no more than 65535 assets. If you change one or more prefabs, you will be asked to synchronize the assets library. Do it by clicking Synchronize button.","title":"How To: Create Asset Library"},{"location":"save-load/#project-item-asset-item","text":"Project Items are used to create tree structures representing the project tree. [ProtoContract] [ProtoInclude(1, typeof(AssetItem))] public class ProjectItem { [ProtoMember(2)] public long ItemID; public string Name; public string Ext; public ProjectItem Parent; public List<ProjectItem> Children; // ... Asset Items are meta representations of assets in a project. They are stored in *.rtmeta files. [ProtoContract] public class AssetItem : ProjectItem { public event EventHandler PreviewDataChanged; [ProtoMember(1)] public Guid TypeGuid; [ProtoMember(2)] public PrefabPart[] Parts; [ProtoMember(3)] public long[] Dependencies; private Preview m_preview; public Preview Preview { get { return m_preview; } set { if (m_preview != value) { m_preview = value; if (PreviewDataChanged != null) { PreviewDataChanged(this, EventArgs.Empty); } } } } public override bool IsFolder { get { return false; } } }","title":"Project Item &amp; Asset Item"},{"location":"save-load/#project","text":"IProject is the main interface of the RTSL library. Here is how to access it: using Battlehub.RTCommon; using Battlehub.RTSL.Interface; void Awake() { IProject project = IOC.Resolve<IProject>(); } Open project: using System.Collections; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { IProject project = IOC.Resolve<IProject>(); yield return project.OpenProject(\"My Project\"); } Close project: m_project.CloseProject(); Delete project: yield return project.DeleteProject(\"My Project\"); Create folder: yield return project.CreateFolder(\"My Scenes\"); Delete folder: yield return project.DeleteFolder(\"My Scenes\"); Save scene: using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Save(\"My Scenes/Scene 1\", SceneManager.GetActiveScene()); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } Load scene: using System.Collections; using UnityEngine; using UnityEngine.SceneManagement; using Battlehub.RTCommon; using Battlehub.RTSL.Interface; IEnumerator Start() { //... ProjectAsyncOperation ao = project.Load<Scene>(\"My Scenes/Scene 1\"); yield return ao; if (ao.Error.HasError) { Debug.LogError(ao.Error.ToString()); } } Delete scene: yield return project.Delete<Scene>(\"My Scenes/Scene 1\"); Find objects of type: foreach(string scene in project.Find<Scene>(\"Scene 1\")) { Debug.Log(scene); } Create Prefab: GameObject primitive = GameObject.CreatePrimitive(PrimitiveType.Capsule); yield return project.Save(\"Capsule\", primitive); Destroy(primitive); Load and instantiate Prefab: ProjectAsyncOperation<Object[]> ao = project.Load<GameObject>(\"Capsule\"); yield return ao; if(!ao.Error.HasError) { Instantiate(ao.Result[0]); } Import all assets from asset bundle: //get names of asset bundles from Assets/StreamingAssets folder. ProjectAsyncOperation<string[]> ao = project.GetAssetBundles(); yield return ao; //load ImportItems from first asset bundle ProjectAsyncOperation<ProjectItem> loadAo = project.LoadImportItems(ao.Result[0], false); yield return loadAo; if (!loadAo.Error.HasError) { //create previews here... //then unload asset bundle assets project.UnloadImportItems(loadAo.Result); //import all yield return project.Import(loadAo.Result.Flatten(true).OfType<ImportItem>().ToArray()); } //log all asset items in project foreach(string path in project.Find<object>(string.Empty, true)) { Debug.Log(path); }","title":"Project"},{"location":"transform-handles/","text":"Transform Handles Docs Overview Runtime Transform Handles are the runtime 3D controls that are used to manipulate items in the scene. There are three built-in transform tools to position , rotate and scale object via transform component. Supplementary controls such as scene gizmo , selection gizmo and grid allows to change viewing angle and projection mode, identify selected objects and orientate in scene space. Another important components: selection component , scene component and handles component allows to select objects, navigate in scene and change transform handles appearance. Scripts, prefabs and example scenes for transform handles can be found in Assets/Battlehub/ RTHandles folder. Note Runtime Transform Handles are simply referred as transform handles through this text Here is how transform handles and components rendered in the game view: All in one: Getting Started Here are four simple steps to get started with transform handles: Create transform handles using Tools->Runtime Handles->Create . Create and select Game Object. Enable object editing using Tools->Runtime Handles->Enable Editing . Hit play. After clicking on the Game Object in game view you should see following: Following actions available by default: Action Input Select Left-click Move (Pan) Hold middle or right mouse button, then drag Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel Undo Shift + Z (Ctrl + Z in player) Redo Shift + Y (Ctrl + Y in player) Note Example scenes can be found in Assets/Battlehub/RTHandles/Demo Base Handle This is the base class of position, rotation and scale transform handles. Therefore all transform handles have following settings: Window - reference to the window . Interaction with transform handle allowed only in case referenced window is active. HighlightOnHover - bool value. If true then transform handles will be highlighted on pointer over. Set it to false if touch input is used. (default: true) Appearance - reference to the runtime handles component . Various visual settings. Model - reference to the prefab with BaseHandle model component attached. If Model is set then default rendering procedure will be disabled and prefab instance will be rendered instead. Targets - array of transforms to be modified by transform handle. GridSize - float value used in unit-snapping mode. By default Unit-snapping mode is activated with 'Shift' key. BeforeDrag - event raised before transform handle drag. Drop - event raised when drag and drop operation completed. Position Handle To create position handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ PositionHandle component. It is possible to adjust color and scale of transform handles using runtime handles component while proportions of individual parts such as lines and arrows are adjustable using Position Handle Model script attached to PositionHandleModel.prefab. To change position handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ PositionHandleModel.prefab and reference it by setting Model field of Position Handle. Position Handle Model script has following fields: Radius - line thickness (default: 0,01). Length - line length (default: 1). Arrow Radius - radius of the arrow cone base (default 0,075). Arrow Length - height of the arrow (default 0,2). Quad Length - light of side of xy, xz and yz quads (default 0,2). Adjustments example: Rotation Handle To create rotation handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RotationHandle component. It is possible to adjust color and scale of transform handles using runtime handles component . Line thickness and proportions of individual parts are adjustable using Rotation Handle Model script attached to RotationHandleModel.prefab. To change rotation handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ RotationHandleModel.prefab and reference it by setting Model field of Rotation Handle. Rotation Handle Model script has following fields: Minor Radius - line thickness (default: 0,0075). Major Radius - x-axis, y-axis, z-axis, inner camera-forward-axis circle radius (default: 1). Outer Radius - outer camera-forward-axis circle radius (default: 1,11). Adjustments example: Scale Handle To create scale handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ ScaleHandle component. It is possible to adjust color and scale of transform handles using runtime handles component . Line thickness and proportions of individual parts are adjustable using Scale Handle Model script attached to ScaleHandleModel.prefab. To change scale handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ ScaleHandleModel.prefab and reference it by setting Model field of Scale Handle. Scale Handle Model script has following fields: Radius - line thickness (default: 0,01). Length - line length (default: 1). Arrow Radius - cap size (default: 0,05). Adjustments example: Locking Axes Assets/Battlehub/RTCommon/Scripts/ LockAxes component will prevent certain transformations from being modified by position , rotation or scale handles. Attach it to selectable Game Object and choose axes you want to lock. Scene Gizmo To create scene gizmo do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ SceneGizmo component. Scene gizmo script has following fields: Window - reference to the window . Interaction with scene gizmo allowed only in case referenced window is active. Btn Projection - UGUI button to switch between orthographic and perspective projection (default: None). Pivot - transformation of the object around which the camera rotates. Size - scene gizmo size (default: 96,96). Offset - scene gizmo offset (default: 0,0). Appearance - reference to the runtime handles component . Various visual settings. Orientation Changing - event fires when camera rotation and position are about to be changed. Orientation Changed - event fires when camera rotation and position are changed. Projection Changed - event fires when camera projection changed. Selection Gizmo Selection gizmo from Assets/Battlehub/RTHandles/Scripts/ SceneGizmo is automatically added to selected game object. To change color or hide selection gizmo use Bounds Color field of runtime handles component . Grid To create grid do following: Select Camera Add Assets/Battlehub/RTHandles/Scripts/ RuntimeGrid component. To change color of the grid use Grid Color field of runtime handles component . Runtime Handles Component Use this script to change appearance of transform handles: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RuntimeHandlesComponent component Runtime Handles Component script has following fields: Colors - transform handles, scene gizmo, selection gizmo and grid colors. Handle Scale - transform handles scale (default: 1). Selection Margin - scale of clickable area around transform handle axes (default: 1). Invert Z Axis - invert position handle z-axis (default: false). Position Handle Arrows Only - hide xy, yz and xz quads (default: false). Runtime Selection Component This is the implementation of default selection behavior. To enable default selection behavior: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RuntimeSelectionComponent . Choose objects you want to make selectable and click Tools->Runtime Handles->Enable Editing . Alternatively add Assets/Battlehub/RTCommon/Scripts/ ExposeToEditor component. Following actions defined in Assets/Battlehub/RTHandles/Scripts/Input/ RuntimeSelectionInput : Action Input Select Left-click Select multiple Hold Shift + left-click (Ctrl + left-click in player) Select all Hold Shift + A (Ctrl + A in player) Runtime Selection Component script has following fields: Window - reference to the window . Position Handle - reference to the position-handle . Rotation Handle - reference to the rotation-handle . Scale Handle - reference to the scale-handle . Box Selection - reference to the box-selection . Pivot - Window.Camera will look at this object. To switch between transform handles using Q W E R keys do following : Add Battlehub/RTHandles/Scripts/Input/ RuntimeToolsInput component. Note If you wish to switch between transform handles programmatically proceed to -> this <- section. Note If you wish to change selection programmatically proceed to -> this <- section. Box Selection To create Box Selection do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ BoxSelection component. Note Game Objects without ExposeToEditor component are invisible to Box Selection. Note Box Selection use Runtime Selection API to store selected objects. Box Selection has following fields: Window - reference to the window . Graphics - sprite which is used to render box selection. Use Camera Space - use camera space for rendering (true) or screen space (false) (default:true) Box Selection Method - box selection method: Loose Fitting - use renderer bounds and collider (default); Bounds Center - use bounds center; Transform Center - use transform center; Use following code to filter objects selected using Box Selection: using UnityEditor; //In this example objects with name \"Capsule\" are filtered out public class FilteringBehaviour : MonoBehaviour { [SerializeField] private BoxSelection m_boxSelection; private void Start() { m_boxSelection.Filtering += OnFiltering; } private void OnDestroy() { if(m_boxSelection != null) { m_boxSelection.Filtering -= OnFiltering; } } private void OnFiltering(object sender, FilteringArgs e) { if (e.Object.name == \"Capsule\") { e.Cancel = true; } } } Runtime Scene Component Runtime Scene Component extends Runtime Selection Component and enables mouse orbiting, movement and zoom. To create Runtime Scene Component do following: Create Game Object Add Assets/Battlehub/RTHandles/Scripts/ RuntimeSelectionComponent . Runtime Scene Component has following fields: View Texture - cursor which is visible during mouse orbiting. Move Texture - cursor which is visible during movement. Grid Size - used by Snap To Grid method. Scene Gizmo - reference to the Scene Gizmo . Grid - reference to the Grid . Following actions defined in Assets/Battlehub/RTHandles/Scripts/Input/ RuntimeSceneInput : Action Input Focus Press F Snap To Grid Press Shift + S (Ctrl + S in player) Move (Pan) Hold middle or right mouse button, then drag Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel","title":"Transform Handles"},{"location":"transform-handles/#transform-handles-docs","text":"","title":"Transform Handles Docs"},{"location":"transform-handles/#overview","text":"Runtime Transform Handles are the runtime 3D controls that are used to manipulate items in the scene. There are three built-in transform tools to position , rotate and scale object via transform component. Supplementary controls such as scene gizmo , selection gizmo and grid allows to change viewing angle and projection mode, identify selected objects and orientate in scene space. Another important components: selection component , scene component and handles component allows to select objects, navigate in scene and change transform handles appearance. Scripts, prefabs and example scenes for transform handles can be found in Assets/Battlehub/ RTHandles folder. Note Runtime Transform Handles are simply referred as transform handles through this text Here is how transform handles and components rendered in the game view: All in one:","title":"Overview"},{"location":"transform-handles/#getting-started","text":"Here are four simple steps to get started with transform handles: Create transform handles using Tools->Runtime Handles->Create . Create and select Game Object. Enable object editing using Tools->Runtime Handles->Enable Editing . Hit play. After clicking on the Game Object in game view you should see following: Following actions available by default: Action Input Select Left-click Move (Pan) Hold middle or right mouse button, then drag Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel Undo Shift + Z (Ctrl + Z in player) Redo Shift + Y (Ctrl + Y in player) Note Example scenes can be found in Assets/Battlehub/RTHandles/Demo","title":"Getting Started"},{"location":"transform-handles/#base-handle","text":"This is the base class of position, rotation and scale transform handles. Therefore all transform handles have following settings: Window - reference to the window . Interaction with transform handle allowed only in case referenced window is active. HighlightOnHover - bool value. If true then transform handles will be highlighted on pointer over. Set it to false if touch input is used. (default: true) Appearance - reference to the runtime handles component . Various visual settings. Model - reference to the prefab with BaseHandle model component attached. If Model is set then default rendering procedure will be disabled and prefab instance will be rendered instead. Targets - array of transforms to be modified by transform handle. GridSize - float value used in unit-snapping mode. By default Unit-snapping mode is activated with 'Shift' key. BeforeDrag - event raised before transform handle drag. Drop - event raised when drag and drop operation completed.","title":"Base Handle"},{"location":"transform-handles/#position-handle","text":"To create position handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ PositionHandle component. It is possible to adjust color and scale of transform handles using runtime handles component while proportions of individual parts such as lines and arrows are adjustable using Position Handle Model script attached to PositionHandleModel.prefab. To change position handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ PositionHandleModel.prefab and reference it by setting Model field of Position Handle. Position Handle Model script has following fields: Radius - line thickness (default: 0,01). Length - line length (default: 1). Arrow Radius - radius of the arrow cone base (default 0,075). Arrow Length - height of the arrow (default 0,2). Quad Length - light of side of xy, xz and yz quads (default 0,2). Adjustments example:","title":"Position Handle"},{"location":"transform-handles/#rotation-handle","text":"To create rotation handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RotationHandle component. It is possible to adjust color and scale of transform handles using runtime handles component . Line thickness and proportions of individual parts are adjustable using Rotation Handle Model script attached to RotationHandleModel.prefab. To change rotation handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ RotationHandleModel.prefab and reference it by setting Model field of Rotation Handle. Rotation Handle Model script has following fields: Minor Radius - line thickness (default: 0,0075). Major Radius - x-axis, y-axis, z-axis, inner camera-forward-axis circle radius (default: 1). Outer Radius - outer camera-forward-axis circle radius (default: 1,11). Adjustments example:","title":"Rotation Handle"},{"location":"transform-handles/#scale-handle","text":"To create scale handle do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ ScaleHandle component. It is possible to adjust color and scale of transform handles using runtime handles component . Line thickness and proportions of individual parts are adjustable using Scale Handle Model script attached to ScaleHandleModel.prefab. To change scale handle proportions modify Assets/Battlehub/RTHandles/Prefabs/ ScaleHandleModel.prefab and reference it by setting Model field of Scale Handle. Scale Handle Model script has following fields: Radius - line thickness (default: 0,01). Length - line length (default: 1). Arrow Radius - cap size (default: 0,05). Adjustments example:","title":"Scale Handle"},{"location":"transform-handles/#locking-axes","text":"Assets/Battlehub/RTCommon/Scripts/ LockAxes component will prevent certain transformations from being modified by position , rotation or scale handles. Attach it to selectable Game Object and choose axes you want to lock.","title":"Locking Axes"},{"location":"transform-handles/#scene-gizmo","text":"To create scene gizmo do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ SceneGizmo component. Scene gizmo script has following fields: Window - reference to the window . Interaction with scene gizmo allowed only in case referenced window is active. Btn Projection - UGUI button to switch between orthographic and perspective projection (default: None). Pivot - transformation of the object around which the camera rotates. Size - scene gizmo size (default: 96,96). Offset - scene gizmo offset (default: 0,0). Appearance - reference to the runtime handles component . Various visual settings. Orientation Changing - event fires when camera rotation and position are about to be changed. Orientation Changed - event fires when camera rotation and position are changed. Projection Changed - event fires when camera projection changed.","title":"Scene Gizmo"},{"location":"transform-handles/#selection-gizmo","text":"Selection gizmo from Assets/Battlehub/RTHandles/Scripts/ SceneGizmo is automatically added to selected game object. To change color or hide selection gizmo use Bounds Color field of runtime handles component .","title":"Selection Gizmo"},{"location":"transform-handles/#grid","text":"To create grid do following: Select Camera Add Assets/Battlehub/RTHandles/Scripts/ RuntimeGrid component. To change color of the grid use Grid Color field of runtime handles component .","title":"Grid"},{"location":"transform-handles/#runtime-handles-component","text":"Use this script to change appearance of transform handles: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RuntimeHandlesComponent component Runtime Handles Component script has following fields: Colors - transform handles, scene gizmo, selection gizmo and grid colors. Handle Scale - transform handles scale (default: 1). Selection Margin - scale of clickable area around transform handle axes (default: 1). Invert Z Axis - invert position handle z-axis (default: false). Position Handle Arrows Only - hide xy, yz and xz quads (default: false).","title":"Runtime Handles Component"},{"location":"transform-handles/#runtime-selection-component","text":"This is the implementation of default selection behavior. To enable default selection behavior: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ RuntimeSelectionComponent . Choose objects you want to make selectable and click Tools->Runtime Handles->Enable Editing . Alternatively add Assets/Battlehub/RTCommon/Scripts/ ExposeToEditor component. Following actions defined in Assets/Battlehub/RTHandles/Scripts/Input/ RuntimeSelectionInput : Action Input Select Left-click Select multiple Hold Shift + left-click (Ctrl + left-click in player) Select all Hold Shift + A (Ctrl + A in player) Runtime Selection Component script has following fields: Window - reference to the window . Position Handle - reference to the position-handle . Rotation Handle - reference to the rotation-handle . Scale Handle - reference to the scale-handle . Box Selection - reference to the box-selection . Pivot - Window.Camera will look at this object. To switch between transform handles using Q W E R keys do following : Add Battlehub/RTHandles/Scripts/Input/ RuntimeToolsInput component. Note If you wish to switch between transform handles programmatically proceed to -> this <- section. Note If you wish to change selection programmatically proceed to -> this <- section.","title":"Runtime Selection Component"},{"location":"transform-handles/#box-selection","text":"To create Box Selection do following: Create Game Object. Add Assets/Battlehub/RTHandles/Scripts/ BoxSelection component. Note Game Objects without ExposeToEditor component are invisible to Box Selection. Note Box Selection use Runtime Selection API to store selected objects. Box Selection has following fields: Window - reference to the window . Graphics - sprite which is used to render box selection. Use Camera Space - use camera space for rendering (true) or screen space (false) (default:true) Box Selection Method - box selection method: Loose Fitting - use renderer bounds and collider (default); Bounds Center - use bounds center; Transform Center - use transform center; Use following code to filter objects selected using Box Selection: using UnityEditor; //In this example objects with name \"Capsule\" are filtered out public class FilteringBehaviour : MonoBehaviour { [SerializeField] private BoxSelection m_boxSelection; private void Start() { m_boxSelection.Filtering += OnFiltering; } private void OnDestroy() { if(m_boxSelection != null) { m_boxSelection.Filtering -= OnFiltering; } } private void OnFiltering(object sender, FilteringArgs e) { if (e.Object.name == \"Capsule\") { e.Cancel = true; } } }","title":"Box Selection"},{"location":"transform-handles/#runtime-scene-component","text":"Runtime Scene Component extends Runtime Selection Component and enables mouse orbiting, movement and zoom. To create Runtime Scene Component do following: Create Game Object Add Assets/Battlehub/RTHandles/Scripts/ RuntimeSelectionComponent . Runtime Scene Component has following fields: View Texture - cursor which is visible during mouse orbiting. Move Texture - cursor which is visible during movement. Grid Size - used by Snap To Grid method. Scene Gizmo - reference to the Scene Gizmo . Grid - reference to the Grid . Following actions defined in Assets/Battlehub/RTHandles/Scripts/Input/ RuntimeSceneInput : Action Input Focus Press F Snap To Grid Press Shift + S (Ctrl + S in player) Move (Pan) Hold middle or right mouse button, then drag Orbit Hold Alt+left-click, then drag Zoom Use the scroll wheel","title":"Runtime Scene Component"},{"location":"vtv/","text":"Virtualizing TreeView Docs Overview The Virtualizing Tree View is a control that displays a hierarchical data. Virtualzing Tree View implements drag & drop, data binding and selection functions. It is highly customizable and can be used to display large collections of data (1000+ items). Getting Started Create Canvas. Add VirtualizingTreeView.prefab from Assets/Battlehub/UIControls/VirtualizingTreeView/Prefabs to hierarchy. Create GettingStarted.cs script and add it to VirtualizingTreeView Game Object. Hit Play. //GetStarted.cs using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using Battlehub.UIControls; //Example of hierarchical data item public class ExampleDataItem { public string Name; //... additional fields here ...// public ExampleDataItem Parent; public List<ExampleDataItem> Children; public ExampleDataItem(string name) { Name = name; Children = new List<ExampleDataItem>(); } public override string ToString() { return Name; } } public class GetStarted : MonoBehaviour { private VirtualizingTreeView m_treeView; //root level data items private List<ExampleDataItem> m_items; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //This event fired for each item that becomes visible m_treeView.ItemDataBinding += OnItemDataBinding; //This event is fired for each expanded item m_treeView.ItemExpanding += OnItemExpanding; //This event is triggered for each item after drag & drop m_treeView.ItemDrop += OnItemDrop; //Create data items m_items = new List<ExampleDataItem>(); for(int i = 0; i < 1000; ++i) { m_items.Add(new ExampleDataItem(\"Data Item \" + i)); } //Populate tree view with data items m_treeView.Items = m_items; } void OnDestroy() { if(m_treeView != null) { m_treeView.ItemDataBinding -= OnItemDataBinding; m_treeView.ItemExpanding -= OnItemExpanding; m_treeView.ItemDrop -= OnItemDrop; } } void OnItemDataBinding(object sender, VirtualizingTreeViewItemDataBindingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Get the controls from ItemsPresenter and copy the data into them. Text text = e.ItemPresenter.GetComponentInChildren<Text>(true); text.text = item.Name; Image icon = e.ItemPresenter.GetComponentsInChildren<Image>()[4]; icon.sprite = Resources.Load<Sprite>(\"IconNew\"); //Notify the tree of the presence of child data items. e.HasChildren = item.Children.Count > 0; } void OnItemExpanding(object sender, VirtualizingItemExpandingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Return children to the tree view e.Children = item.Children; } void OnItemDrop(object sender, ItemDropArgs args) { if (args.DropTarget == null) { return; } //Handle ItemDrop event using standard handler. m_treeView.ItemDropStdHandler<ExampleDataItem>(args, (item) => item.Parent, (item, parent) => item.Parent = parent, (item, parent) => ChildrenOf(parent).IndexOf(item), (item, parent) => ChildrenOf(parent).Remove(item), (item, parent, i) => ChildrenOf(parent).Insert(i, item)); } List<ExampleDataItem> ChildrenOf(ExampleDataItem parent) { if (parent == null) { return m_items; } return parent.Children; } } You should see scrollable tree view with data items and drag & drop support: Note Full demo can be found in Assets/Battelhub/UIControls/VirtualizingTreeView/Demo folder Virtualizing Scroll Rect This class reuses \"ui containers\" to efficiently represent large collections of data elements. UI containers are created for a small visible part of the data elements. VirtualizingScrollRect.cs can be found in Assets/Battlehub/UIControls/VirtualizingTreeView/Scripts/ folder. Events: event DataBindAction ItemDataBinding - raised when new portion of data become visible . Fields: Container Prefab - prefab, which is used to create instances of ui containers for data items. Virtual Content - parent of ui containers. Properties: IList Items { get; set; } - gets or sets list of data items. int ItemsCount{ get; } - gets the number of data items. int Index { get; set; } - gets or sets index of first visible data item. int VisibleItemsCount { get; } - gets the number of currently visible data items. Methods: bool IsParentOf(Transform child) - returns true if the Scroll Rect is the parent of the Transform. void InsertItem(int index, object item, bool raiseDataBindingEvent = true) - insert data item. void RemoveItems(int[] indices, bool raiseItemDataBindingEvent = true) - remove data items. RectTransform GetContainer(object obj) - returns the ui container for data item. RectTransform FirstContainer() - returns the first visible ui container. RectTransform LastContainer() - returns the last visible ui container. void ForEachContainer(System.Action<RectTransform> action) - run action for each ui container. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers. Virtualizing Items Control This class implements drag and drop, insert, delete, reorder functions and triggers many useful events. It also serves as the base class for controls, such as listbox and treeview. Implementation can be found in /Battlehub/UIControls/VirtualizingTreeView/Scripts/ folder. Events: event EventHandler<ItemArgs> ItemBeginDrag - raised on begin drag. event EventHandler<ItemDropCancelArgs> ItemBeginDrop - raised on item drop. event EventHandler<ItemDropCancelArgs> ItemDragEnter - occurs when the pointer enters a new drop target. event EventHandler ItemDragExit - raised when pointer leaves drop area. event EventHandler<ItemArgs> ItemDrag - fired while dragging an item. event EventHandler<ItemDropArgs> ItemDrop - fired after item dropped. event EventHandler<ItemArgs> ItemEndDrag - raised when drag & drop operation completed. event EventHandler<SelectionChangedArgs> SelectionChanged - occurs when the selection is changed. event EventHandler<ItemArgs> ItemDoubleClick - triggered after double clicking on an item. event EventHandler<ItemArgs> ItemClick - triggered after clicking on an item. event EventHandler<ItemsCancelArgs> ItemsRemoving - triggered before removing items. event EventHandler<ItemsRemovedArgs> ItemsRemoved - triggered after removing items. event EventHandler IsFocusedChanged - raised when IsFocused value changed. event EventHandler Submit - on submit. event EventHandler Cancel - on cancel. event EventHandler<PointerEventArgs> Click - triggered after clicking on the tree view. event EventHandler<PointerEventArgs> PointerEnter - occurs when the pointer enters the tree view. event EventHandler<PointerEventArgs> PointerExit - occurs when the pointer leaves the tree view. event EventHandler<TDataBindingArgs> ItemDataBinding - occurs when a new ui container is created or an update is required. event EventHandler<TDataBindingArgs> ItemBeginEdit - occurs when the ui container enters edit mode, and the EditorPresenter becomes visible. event EventHandler<TDataBindingArgs> ItemEndEdit - occurs when the ui container exit edit mode, and the ItemsPresenter becomes visible. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - can the user unselect all items? If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Properties: object DropTarget { get; } - get currently active drop target. object[] DragItems { get; } - get items that are currently dragging. ItemDropAction DropAction { get; } - get current drop action: None , SetLastChild , SetPrevSilbing , SetNextSibling . int SelectedItemsCount { get; } - get selected data items count. IEnumerable SelectedItems { get; set; } - get or set selected data items. object SelectedItem { get; set; } - get or set selected data item. int SelectedIndex { get; set; } - get or set index of selected data item. IEnumerable Items { get; set; } - data source. Methods: int IndexOf(object obj) - get the index of the data item. void SetIndex(object obj, int newIndex) - set index of data item. VirtualizingItemContainer GetItemContainer(object item) - get the visible ui container. ItemContainerData GetItemContainerData(object item) - get the state of the ui container. ItemContainerData Add(object item) - add data item. ItemContainerData Insert(int index, object item) - insert data item. void Remove(object item) - remove data item. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers. Virtualizing Drop Marker The Virtualizing Drop Marker is used to highlight the drop location of the item. Virtualizing Drop Marker can be in one of the states defined in the ItemDropAction enum. public enum ItemDropAction { None, SetLastChild, SetPrevSibling, SetNextSibling } Virtualizing Tree View Structure: Prefab: Assets/Battelhub/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeView.prefab . Script: Assets/Battelhub/UIControls/VirtualizingTreeView/Scripts/VirtualizingTreeView.cs . Base Class: Virtualizing Items Control Events: event EventHandler<VirtualizingItemExpandingArgs> ItemExpanding - triggered before the parent item expands. event EventHandler<VirtualizingItemCollapsedArgs> ItemCollapsed - triggered after folding the parent item. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). bool CanReparent - Is parent change allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Methods: void AddChild(object parent, object item) - add child item. void RemoveChild(object parent, object item) - remove child item. bool Expand(object item) - expand item fails and returns false if the element is not visible and is a descendant of the collapsed parent) . void ExpandTo<T>(T item, Func<T,T> getParent) - expand all ancestors. void ExpandChildren<T>(T item, Func<T, IEnumerable> getChildren) - expand all descendants. void ExpandAll(T item, Func<T,T> getParent, Func<T, IEnumerable> getChildren) - calls ExpandTo, then ExpandChildren. void Collapse(object item) - collapse item. Examples: //Select all root items private VirtualizingTreeView m_treeView; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //..Initialization and data binding... m_treeView.SelectionChanged += OnSelectionChanged; m_treeView.SelectedItems = m_treeView.Items; } void OnDestroy() { if(m_treeView != null) { m_treeView.SelectionChanged -= OnSelectionChanged; } } private void OnSelectionChanged(object sender, SelectionChangedArgs e) { if(e.NewItems != null) { foreach(object item in e.NewItems) { Debug.Log(item); } } } //Add children and expand selected items public void Add() { foreach (ExampleDataItem parent in m_treeView.SelectedItems) { ExampleDataItem item = new ExampleDataItem(\"New Item\"); parent.Children.Add(item); item.Parent = parent; m_treeView.AddChild(parent, item); m_treeView.Expand(parent); } } //Collapse selected items public void Collapse() { foreach (DataItem selectedItem in TreeView.SelectedItems) { TreeView.Collapse(selectedItem); } } //Expand selected items and their children public void Expand() { foreach(ExampleDataItem selectedItem in m_treeView.SelectedItems) { m_treeView.ExpandAll(selectedItem, item => item.Parent, item => item.Children); } } //Remove selected items public void Remove() { foreach (ExampleDataItem selectedItem in m_treeView.SelectedItems.OfType<object>().ToArray()) { m_treeView.RemoveChild(selectedItem.Parent, selectedItem); } } Note ExampleDataItem is defined in Getting Started section. Virtualizing Tree View Item Structure: Prefab: Battelhub/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeViewItem.prefab . Script: Battelhub/UIControls/VirtualizingTreeView/Scripts/VirtualizingTreeViewItem.cs . Fields: ItemPresenter - normal mode ui. EditorPresenter - edit mode ui. ItemLayout - reference to LayoutElement.","title":"Virtualizing Tree View"},{"location":"vtv/#virtualizing-treeview-docs","text":"","title":"Virtualizing TreeView Docs"},{"location":"vtv/#overview","text":"The Virtualizing Tree View is a control that displays a hierarchical data. Virtualzing Tree View implements drag & drop, data binding and selection functions. It is highly customizable and can be used to display large collections of data (1000+ items).","title":"Overview"},{"location":"vtv/#getting-started","text":"Create Canvas. Add VirtualizingTreeView.prefab from Assets/Battlehub/UIControls/VirtualizingTreeView/Prefabs to hierarchy. Create GettingStarted.cs script and add it to VirtualizingTreeView Game Object. Hit Play. //GetStarted.cs using System.Collections.Generic; using UnityEngine; using UnityEngine.UI; using Battlehub.UIControls; //Example of hierarchical data item public class ExampleDataItem { public string Name; //... additional fields here ...// public ExampleDataItem Parent; public List<ExampleDataItem> Children; public ExampleDataItem(string name) { Name = name; Children = new List<ExampleDataItem>(); } public override string ToString() { return Name; } } public class GetStarted : MonoBehaviour { private VirtualizingTreeView m_treeView; //root level data items private List<ExampleDataItem> m_items; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //This event fired for each item that becomes visible m_treeView.ItemDataBinding += OnItemDataBinding; //This event is fired for each expanded item m_treeView.ItemExpanding += OnItemExpanding; //This event is triggered for each item after drag & drop m_treeView.ItemDrop += OnItemDrop; //Create data items m_items = new List<ExampleDataItem>(); for(int i = 0; i < 1000; ++i) { m_items.Add(new ExampleDataItem(\"Data Item \" + i)); } //Populate tree view with data items m_treeView.Items = m_items; } void OnDestroy() { if(m_treeView != null) { m_treeView.ItemDataBinding -= OnItemDataBinding; m_treeView.ItemExpanding -= OnItemExpanding; m_treeView.ItemDrop -= OnItemDrop; } } void OnItemDataBinding(object sender, VirtualizingTreeViewItemDataBindingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Get the controls from ItemsPresenter and copy the data into them. Text text = e.ItemPresenter.GetComponentInChildren<Text>(true); text.text = item.Name; Image icon = e.ItemPresenter.GetComponentsInChildren<Image>()[4]; icon.sprite = Resources.Load<Sprite>(\"IconNew\"); //Notify the tree of the presence of child data items. e.HasChildren = item.Children.Count > 0; } void OnItemExpanding(object sender, VirtualizingItemExpandingArgs e) { ExampleDataItem item = (ExampleDataItem)e.Item; //Return children to the tree view e.Children = item.Children; } void OnItemDrop(object sender, ItemDropArgs args) { if (args.DropTarget == null) { return; } //Handle ItemDrop event using standard handler. m_treeView.ItemDropStdHandler<ExampleDataItem>(args, (item) => item.Parent, (item, parent) => item.Parent = parent, (item, parent) => ChildrenOf(parent).IndexOf(item), (item, parent) => ChildrenOf(parent).Remove(item), (item, parent, i) => ChildrenOf(parent).Insert(i, item)); } List<ExampleDataItem> ChildrenOf(ExampleDataItem parent) { if (parent == null) { return m_items; } return parent.Children; } } You should see scrollable tree view with data items and drag & drop support: Note Full demo can be found in Assets/Battelhub/UIControls/VirtualizingTreeView/Demo folder","title":"Getting Started"},{"location":"vtv/#virtualizing-scroll-rect","text":"This class reuses \"ui containers\" to efficiently represent large collections of data elements. UI containers are created for a small visible part of the data elements. VirtualizingScrollRect.cs can be found in Assets/Battlehub/UIControls/VirtualizingTreeView/Scripts/ folder. Events: event DataBindAction ItemDataBinding - raised when new portion of data become visible . Fields: Container Prefab - prefab, which is used to create instances of ui containers for data items. Virtual Content - parent of ui containers. Properties: IList Items { get; set; } - gets or sets list of data items. int ItemsCount{ get; } - gets the number of data items. int Index { get; set; } - gets or sets index of first visible data item. int VisibleItemsCount { get; } - gets the number of currently visible data items. Methods: bool IsParentOf(Transform child) - returns true if the Scroll Rect is the parent of the Transform. void InsertItem(int index, object item, bool raiseDataBindingEvent = true) - insert data item. void RemoveItems(int[] indices, bool raiseItemDataBindingEvent = true) - remove data items. RectTransform GetContainer(object obj) - returns the ui container for data item. RectTransform FirstContainer() - returns the first visible ui container. RectTransform LastContainer() - returns the last visible ui container. void ForEachContainer(System.Action<RectTransform> action) - run action for each ui container. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers.","title":"Virtualizing Scroll Rect"},{"location":"vtv/#virtualizing-items-control","text":"This class implements drag and drop, insert, delete, reorder functions and triggers many useful events. It also serves as the base class for controls, such as listbox and treeview. Implementation can be found in /Battlehub/UIControls/VirtualizingTreeView/Scripts/ folder. Events: event EventHandler<ItemArgs> ItemBeginDrag - raised on begin drag. event EventHandler<ItemDropCancelArgs> ItemBeginDrop - raised on item drop. event EventHandler<ItemDropCancelArgs> ItemDragEnter - occurs when the pointer enters a new drop target. event EventHandler ItemDragExit - raised when pointer leaves drop area. event EventHandler<ItemArgs> ItemDrag - fired while dragging an item. event EventHandler<ItemDropArgs> ItemDrop - fired after item dropped. event EventHandler<ItemArgs> ItemEndDrag - raised when drag & drop operation completed. event EventHandler<SelectionChangedArgs> SelectionChanged - occurs when the selection is changed. event EventHandler<ItemArgs> ItemDoubleClick - triggered after double clicking on an item. event EventHandler<ItemArgs> ItemClick - triggered after clicking on an item. event EventHandler<ItemsCancelArgs> ItemsRemoving - triggered before removing items. event EventHandler<ItemsRemovedArgs> ItemsRemoved - triggered after removing items. event EventHandler IsFocusedChanged - raised when IsFocused value changed. event EventHandler Submit - on submit. event EventHandler Cancel - on cancel. event EventHandler<PointerEventArgs> Click - triggered after clicking on the tree view. event EventHandler<PointerEventArgs> PointerEnter - occurs when the pointer enters the tree view. event EventHandler<PointerEventArgs> PointerExit - occurs when the pointer leaves the tree view. event EventHandler<TDataBindingArgs> ItemDataBinding - occurs when a new ui container is created or an update is required. event EventHandler<TDataBindingArgs> ItemBeginEdit - occurs when the ui container enters edit mode, and the EditorPresenter becomes visible. event EventHandler<TDataBindingArgs> ItemEndEdit - occurs when the ui container exit edit mode, and the ItemsPresenter becomes visible. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - can the user unselect all items? If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Properties: object DropTarget { get; } - get currently active drop target. object[] DragItems { get; } - get items that are currently dragging. ItemDropAction DropAction { get; } - get current drop action: None , SetLastChild , SetPrevSilbing , SetNextSibling . int SelectedItemsCount { get; } - get selected data items count. IEnumerable SelectedItems { get; set; } - get or set selected data items. object SelectedItem { get; set; } - get or set selected data item. int SelectedIndex { get; set; } - get or set index of selected data item. IEnumerable Items { get; set; } - data source. Methods: int IndexOf(object obj) - get the index of the data item. void SetIndex(object obj, int newIndex) - set index of data item. VirtualizingItemContainer GetItemContainer(object item) - get the visible ui container. ItemContainerData GetItemContainerData(object item) - get the state of the ui container. ItemContainerData Add(object item) - add data item. ItemContainerData Insert(int index, object item) - insert data item. void Remove(object item) - remove data item. void SetNextSibling(object sibling, object nextSibling) - reorder data items and ui containers. void SetPrevSibling(object sibling, object prevSibling) - reorder data items and ui containers.","title":"Virtualizing Items Control"},{"location":"vtv/#virtualizing-drop-marker","text":"The Virtualizing Drop Marker is used to highlight the drop location of the item. Virtualizing Drop Marker can be in one of the states defined in the ItemDropAction enum. public enum ItemDropAction { None, SetLastChild, SetPrevSibling, SetNextSibling }","title":"Virtualizing Drop Marker"},{"location":"vtv/#virtualizing-tree-view","text":"Structure: Prefab: Assets/Battelhub/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeView.prefab . Script: Assets/Battelhub/UIControls/VirtualizingTreeView/Scripts/VirtualizingTreeView.cs . Base Class: Virtualizing Items Control Events: event EventHandler<VirtualizingItemExpandingArgs> ItemExpanding - triggered before the parent item expands. event EventHandler<VirtualizingItemCollapsedArgs> ItemCollapsed - triggered after folding the parent item. Fields: bool SelectOnPointerUp - select item on pointer up (default: false). bool CanUnselectAll - If set to false then at least one item has to be selected (default: true). bool CanSelectAll - can the user select all items? (default:true). bool CanEdit - can the user edit items? (default: true). bool CanRemove - can the user remove items? (default: true). bool CanDrag - is drag & drop allowed? (default:true). bool CanReorder - Is the reordering of items allowed? (default: true). bool CanReparent - Is parent change allowed? (default: true). float ScrollSpeed - scrolling sensitivity. Methods: void AddChild(object parent, object item) - add child item. void RemoveChild(object parent, object item) - remove child item. bool Expand(object item) - expand item fails and returns false if the element is not visible and is a descendant of the collapsed parent) . void ExpandTo<T>(T item, Func<T,T> getParent) - expand all ancestors. void ExpandChildren<T>(T item, Func<T, IEnumerable> getChildren) - expand all descendants. void ExpandAll(T item, Func<T,T> getParent, Func<T, IEnumerable> getChildren) - calls ExpandTo, then ExpandChildren. void Collapse(object item) - collapse item. Examples: //Select all root items private VirtualizingTreeView m_treeView; void Start() { m_treeView = GetComponent<VirtualizingTreeView>(); //..Initialization and data binding... m_treeView.SelectionChanged += OnSelectionChanged; m_treeView.SelectedItems = m_treeView.Items; } void OnDestroy() { if(m_treeView != null) { m_treeView.SelectionChanged -= OnSelectionChanged; } } private void OnSelectionChanged(object sender, SelectionChangedArgs e) { if(e.NewItems != null) { foreach(object item in e.NewItems) { Debug.Log(item); } } } //Add children and expand selected items public void Add() { foreach (ExampleDataItem parent in m_treeView.SelectedItems) { ExampleDataItem item = new ExampleDataItem(\"New Item\"); parent.Children.Add(item); item.Parent = parent; m_treeView.AddChild(parent, item); m_treeView.Expand(parent); } } //Collapse selected items public void Collapse() { foreach (DataItem selectedItem in TreeView.SelectedItems) { TreeView.Collapse(selectedItem); } } //Expand selected items and their children public void Expand() { foreach(ExampleDataItem selectedItem in m_treeView.SelectedItems) { m_treeView.ExpandAll(selectedItem, item => item.Parent, item => item.Children); } } //Remove selected items public void Remove() { foreach (ExampleDataItem selectedItem in m_treeView.SelectedItems.OfType<object>().ToArray()) { m_treeView.RemoveChild(selectedItem.Parent, selectedItem); } } Note ExampleDataItem is defined in Getting Started section.","title":"Virtualizing Tree View"},{"location":"vtv/#virtualizing-tree-view-item","text":"Structure: Prefab: Battelhub/UIControls/VirtualizingTreeView/Prefabs/VirtualizingTreeViewItem.prefab . Script: Battelhub/UIControls/VirtualizingTreeView/Scripts/VirtualizingTreeViewItem.cs . Fields: ItemPresenter - normal mode ui. EditorPresenter - edit mode ui. ItemLayout - reference to LayoutElement.","title":"Virtualizing Tree View Item"}]}